В этом уроке вас ждёт знакомство с двумя схожими группами операций: логическими и побитовыми. Вы узнаете, как и для чего они перегружаются, а также рассмотрите необычный подход к использованию поразрядных операций для работы с флагами.

### Логические операции

Вы уже знаете, что логические операции работают с выражениями типа `bool` и позволяют их комбинировать. В C++ таких операций всего три:

- Логическое И (`&&`) — возвращает `true`, если оба условия истинны.
- Логическое ИЛИ (`||`) — возвращает `true`, если хотя бы одно условие истинно.
- Логическое отрицание (`!`) — инвертирует значение.

Чаще всего логические операции используются для проверки нескольких условий.

```cpp
bool writes_with_left_hand = true;
bool uses_scissors_with_left_hand = false;

// Если человек пишет И держит ножницы левой рукой, он левша.
if (writes_with_left_hand && uses_scissors_with_left_hand) {
    std::cout << "You're left-handed"s;

// Если он ИЛИ пишет, ИЛИ держит ножницы левой рукой — у него смешанный тип.
} else if (writes_with_left_hand || uses_scissors_with_left_hand) {
    std::cout << "You're mixed-handed"s;
} 
```

Синтаксис перегрузки аналогичен перегрузкам других бинарных операций. Она получает два операнда и возвращает результат, который может быть либо типа `bool`, либо любого другого типа.

В качестве примера рассмотрим уже знакомый вам класс `Interval`. Мы можем использовать логическое И (`&&`) для нахождения общей части двух диапазонов.

```cpp
class Interval {
    ...
    Interval operator&&(const Interval& other) {
        int new_start = std::max(start_, other.start_);
        int new_end = std::min(end_, other.end_);
        
        if (new_start <= new_end) {
            return Interval(new_start, new_end);
        }
        return Interval();
    }
private:
    int start_, end_;
};
...

Interval inter = Interval(2, 6) && Interval(4, 19); // [4, 6]. 
```

Напомним, что при выполнении логических операций в C++ используются **ленивые вычисления**: если посчитанная часть выражения позволяет предсказать результат, остальные части не вычисляются. Например, если функция `IsLeftHanded` возвращает `true`, условие будет выполнено независимо от значения `IsRightHanded`. Компилятор может сразу дать ответ, не вызывая `IsRightHanded`.

```cpp
if (IsLeftHanded() || IsRightHanded()) {
    std::cout << "You're mixed-handed"s;
} 
```

Перегруженные логические операции работают без этой оптимизации: выражения всегда будут рассчитываться целиком.

### Поразрядные операции

Поразрядные операции во многом похожи на логические. Главное отличие состоит в том, что они работают с отдельными битами (разрядами) значений.

Чтобы это продемонстрировать, представим операнды `a` и `b` в двоичной системе счисления:

- `а` = 15 = 00001111,
    
- `b` = 19 = 00010011.
    

Побитовое ИЛИ (`|`) будет выполнено для каждого разряда и вернёт 00011111. Побитовое И (`&`) аналогичным образом вернёт 00000011.

```cpp
#include <bitset> // Подключаем, чтобы вывести биты числа.

int main() {
    int a = 0b00001111; // Число 15 в двоичной записи.
    int b = 0b00010011; // Число 19 в двоичной записи.

    // Выведем результат поразрядного ИЛИ в двоичном виде.
    // Получим 00011111.
    std::cout << std::bitset<8>(a | b)  << std::endl;
    
    // Результат поразрядного И: 00000011.
    std::cout << std::bitset<8>(a & b)  << std::endl;
} 
```

Для работы с побитовыми операциями не обязательно использовать двоичное представление.

```cpp
int a = 15; 
int b = 18; 

std::cout << std::bitset<8>(a | b)  << std::endl; // Всё ещё 00011111.
std::cout << (a | b)  << std::endl; // 31 (00011111 в десятичной системе). 
```

В C++ существует шесть побитовых операций:

- `&` — поразрядное И;
- `|` — поразрядное ИЛИ;
- `^` — поразрядное исключающее ИЛИ: возвращает 0, если операнды равны;
- `~` — поразрядное отрицание;
- `<<` и `>>` — операции сдвига: сдвигают биты числа влево или вправо на указанное количество позиций.

На практике поразрядные операции могут применяться для работы с флагами. Флаг представляет собой значение, в котором все разряды, кроме одного, равны нулю.

```
enum class UserRoles {
    Admin = 1,  // Равно 2 в степени 0 = 0001.
    Editor = 2, // Равно 2 в степени 1 = 0010.
    Viewer = 4  // Равно 2 в степени 2 = 0100.
}; 
```

Длина флага в битах может быть произвольной — главное, чтобы её хватало для записи всех позиций единицы. В этом примере мы взяли длину в четыре бита.

Чтобы элементы перечисления имели одну единицу в двоичном представлении, они должны равняться степеням двойки.

Флаги используются для отражения каких-либо свойств объекта. В нашем примере пользователь может иметь роли `Admin`, `Editor` и `Viewer` или любую их комбинацию. Если у пользователя есть роли `Admin` и `Viewer`, комбинация его флагов будет `0001` | `0100` = `0101`.

```
enum class UserRoles {
    Admin = 1,  // 0001.
    Editor = 2, // 0010.
    Viewer = 4  // 0100.
};

// Перегрузка для работы с типом UserRoles.
int operator|(unsigned int a, UserRoles b) {
    return a | static_cast<int>(b);
}

int main() {
    unsigned int user_role = 0; // Сначала у пользователя нет флагов (0000).
    
    // Добавляем флаг Admin: 0000 | 0001 = 0001.
    user_role = user_role | UserRoles::Admin;
    
    // Добавляем флаг Viewer: 0001 | 0100 = 0101.
    user_role = user_role | UserRoles::Viewer;
} 
```

Чтобы проверить наличие определённого флага, можно использовать операцию `&`.

```
// Перегрузка для работы с типом UserRoles.
int operator&(unsigned int a, UserRoles b) {
    return a & static_cast<int>(b);
}
...

// 0101 & 0001 = 0001 = true
if (user_role & UserRoles::Admin) {
    std::cout << "У вас есть права администратора"s << std::endl;
}
// 0101 & 0010 = 0000 = false
if (!(user_role & UserRoles::Editor)) {
    std::cout << "У вас нет прав редактора"s << std::endl;
} 
```

С помощью поразрядных операций можно выполнять и другие действия над флагами: снимать, инвертировать и так далее.