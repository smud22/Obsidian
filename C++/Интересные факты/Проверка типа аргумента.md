Метод `Perimeter` суммирует стороны треугольника. Чтобы сделать это корректно, необходимо знать их тип: если он простой, можно просто обратиться к полям структуры — `triangle_1.a + triangle_2.a`. Если же это тип `Side`, для получения длины нужно использовать его метод: `triangle_1.a.GetLength() + triangle_2.a.GetLength()`. Для проверки типа используется конструкция `std::is_same_v<T, Side>`.

```cpp
template <typename T> 
struct Triangle {
    Triangle(T a, T b, T c): a(a), b(b), c(c) {}
    
    T Perimeter() const {
        // С обычным if — ошибка при подстановке int:
        // у типа int нет метода GetLength().
        if constexpr (std::is_same_v<T, Side>) {
            // Если стороны треугольника имеют тип Side,
            // нужно использовать метод GetLength().
            return a.GetLength() + b.GetLength() + c.GetLength();
        } else {
            // Иначе достаточно просто взять их значения.
            return a + b + c;
        }
    }
    
    T a, b, c;
};

int main() {
    // Стороны треугольника заданы типом int.
    std::cout << Triangle{3, 5, 4}.Perimeter() << std::endl;
    
    // Стороны треугольника заданы типом Side.
    Side side{1};
    std::cout << Triangle{side, side, side}.Perimeter()
              << std::endl;
} 
```

Конструкция `if constexpr` позволяет исключить ненужный код, оставив тот, что подходит для переданного типа. В этом случае обычный `if` привёл бы к ошибке: если компилятор оставит обе условные ветви и попытается их разобрать, то обнаружит, что у типа `int` нет метода `GetLength`.