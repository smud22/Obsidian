Из всех функций-кандидатов, видимых в точке вызова функции, компилятор выбирает множество **жизнеспособных** (они так и называются в стандарте языка: viable functions) по следующим правилам:

- Сначала рассматриваются функции, принимающие нужное количество аргументов. Например, если вызывается функция с тремя аргументами, то жизнеспособными будут функции, имеющие три аргумента.
- Жизнеспособными функциями будут и функции, принимающие большее количество аргументов, если недостающие аргументы имеют значения по умолчанию.

```cpp
void Print(int number, int base = 10) { ... }                    // (1)
void Print(double number) { ... }                                // (2)
void Print(const std::string& name, const std::string& surname); // (3)

int main() {
    Print(5);
} 
```

В этом примере при вызове `Print(5)` жизнеспособными будут функции (1) и (2), так как они могут быть вызваны с одним аргументом.

При вызове функции может происходить неявное преобразование типов. Например, функцию `void PrintPoint(double x, double y)` можно вызвать и с параметрами типа `int` — они будут преобразованы к типу `double`. Если имеются несколько одноимённых функций, то компилятор выберет жизнеспособного кандидата с наиболее точным соответствием типов переданных и принимаемых аргументов.

Проверка на соответствие типов подразделяется на три ранга. Чем меньше номер ранга, тем лучше соответствие:

1. **Полное совпадение:** преобразование типа не требуется.
2. **Расширение типа:** расширение целочисленных типов `bool`, `char`, `short int` до типа `int`, либо расширение `float` до `double`.
3. **Преобразования типов:** целочисленное преобразование `int` в `unsigned int` и обратно, `double` во `float`, преобразование вещественных чисел в целые и обратно. Есть и другие преобразования, которые будут рассматриваться в других темах.

Компилятор также справляется с выбором функции, когда есть неконфликтующие между собой преобразования типов:

```cpp
int main() {
    // Выведет "double 3.5", выполнив неявное преобразование float в double.
    Print(3.5f);
    // Выведет "int 65", выполнив неявное преобразование char в int.
    Print('A');
} 
```

Преобразования из `unsigned int` в `int` и из `unsigned int` в `double` имеют одинаковый ранг, поэтому здесь компилятор не сможет однозначно выбрать подходящую функцию:

```cpp
int main() {
    unsigned x = 42;
    Print(x); // Print(int) или Print(double)?
} 
```

Чтобы помочь компилятору разрешить проблему, нужно выполнить явное приведение типа:

```cpp
int main() {
    unsigned x = 42;

    Print(static_cast<int>(x));    // Вызовет Print(int).
    // или так:
    Print(static_cast<double>(x)); // Вызовет Print(double).
} 
```