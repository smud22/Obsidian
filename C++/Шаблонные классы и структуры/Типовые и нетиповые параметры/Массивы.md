В каких случаях нетиповые параметры могут быть полезны? Давайте рассмотрим классический пример их применения — **статические массивы**. Это тип данных, во многом похожий на знакомый вам вектор: в него можно записывать значения одинакового типа и обращаться к ним с помощью индекса.

```cpp
int main() {
    std::string week_names[7] = {"Понедельник"s, "Вторник"s, ... "Воскресенье"s};
    std::cout << week_names[1]; // "Вторник".
} 
```

Главное отличие состоит в том, что размер массива — фиксированная величина, которая задаётся на этапе компиляции и не может меняться. По этой причине статические массивы не поддерживают операции `push_back` и `resize`. Но в этом же кроется их преимущество: массивы требуют меньше накладных расходов, чем векторы.

Попытка создать массив с заранее неизвестной длиной приведёт к ошибке.

```cpp
struct Array {
    Array(size_t new_size): size(new_size) {}
    size_t size;
    int data[size]; // <- Ошибка!
};

int main() {
    auto a = Array(5);
} 
```

Несмотря на то что размер массива указан в коде, объявление будет происходить во время выполнения программы, что недопустимо. Перепишем этот код, передав длину как нетиповой параметр. Для этого используются угловые скобки `<>`.

```cpp
template <size_t Size>
struct Array {
  int data[Size];
};

int main() {
    auto a = Array<5>(); // Ок.
} 
```

На этот раз число `5` записывается в `Size` на этапе компиляции, и ошибка не происходит.

Нетиповые параметры можно использовать вместе с типовыми (например, чтобы создавать массивы не только для целых чисел).

```cpp
template <typename T, size_t Size>
struct Array {
  T data[Size];
};

int main() {
    auto a = Array<double, 5>();
} 
```