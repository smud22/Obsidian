Вы уже знаете, что нетиповые параметры подставляются в шаблон во время инстанцирования. На практике — их значения должны быть известны (или вычисляемы) на этапе компиляции. Мы не сможем передать в шаблон значение, которое станет известно только при выполнении программы.

```cpp
template <int Size>
class TicTacToe {
public:
    TicTacToe() = default;

private:
    int board_[Size];
};

int main() {
    TicTacToe<3> tic_tac_game_1; // Ок.
      
    int size;
    std::cin >> size;
    TicTacToe<size> tic_tac_game_2; // Ошибка!
} 
```

В некоторых случаях это ограничение можно обойти, заранее инстанцировав шаблон на возможные значения.

```cpp
// При вызове компилятор сам определит
// значение Size по типу.
template<int Size>
void DoTick(const TicTacToe<Size>& /*tick_tac_toe*/) {
    std::cout << "Board side size = "s 
              << Size << std::endl;
}

int main() {
    size_t size;
    std::cin >> size;
    
    // Используем константу вместо значения
    // size напрямую.
    switch(size) {
    case 2: 
        DoTick(TicTacToe<2>()); // 2 – известно на этапе компиляции.
        break;
    case 3:
        DoTick(TicTacToe<3>()); // 3 – известно на этапе компиляции.
        break;
    case 4:
        DoTick(TicTacToe<4>()); // 4 – известно на этапе компиляции.
        break;
    };
} 
```

Для нетиповых параметров также возможен вывод типов — даже достаточно сложный. В примере выше мы вывели нетиповой параметр функции `DoTick` из параметра класса. Ещё компилятор может вывести значение параметра по списку инициализации.

```cpp
template<typename T, int Size> 
void PrintArray(T const(&array)[Size]) {
    for (int i = 0; i < Size; i++) {
        std::cout << array[i] << " "s;
    }
}

int main() {
    PrintArray({1, 2, 3}); // Т = int, Size = 3.
} 
```