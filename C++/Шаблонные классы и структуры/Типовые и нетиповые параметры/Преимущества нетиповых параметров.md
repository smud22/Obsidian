Нетиповые параметры помогают не только при объявлении массивов. Поскольку они являются константами, компилятор может использовать их для оптимизации кода, заранее заменяя константные переменные и выражения их фактическими значениями. Это позволяет выполнить часть вычислений на этапе компиляции, что положительно сказывается на производительности программы.

Хорошей иллюстрацией такой оптимизации является случай, когда от значения константы зависит выполнение того или иного блока кода (например, при использовании оператора `if`). Если компилятор способен заранее определить результат условия, он может исключить ветви, которые не будут использоваться, и в результате избежать лишних проверок.

Рассмотрим пример с функцией, суммирующей несколько точек либо по координате `x`, либо по `y`.

```cpp
template <typename T, bool use_x>
T SumPoints(std::vector<Point<T>> points) {
    T sum_point = T(0);
    for (auto point : points) {
        // Если use_x == true, суммируем координаты по х.
        if (use_x) { 
            sum_point += point.x;
        } 
        // Иначе суммируем по y.
        else { 
            sum_point += point.y;
        }
    }
    return sum_point;
}

int main() {
    auto points = std::vector<Point<int>> {{1, 101}, {2, 201}, {3, 301}};
    std::cout << SumPoints<int, true>(points) << std::endl; // 6.
    std::cout << SumPoints<int, false>(points) << std::endl; // 603.
} 
```

В обычном случае проверка флага `use_x` выполнялась бы для каждой точки. Здесь же он является нетиповым параметром с неизменным значением. Благодаря этому компилятор знает, что результат проверки условия в рамках вызванной функции будет одним и тем же, и может сразу оставить только нужный код.

С точки зрения компилятора после инстанцирования шаблонных параметров и оптимизации функция будет выглядеть так:

```cpp
int SumPoints<int, true>(std::vector<Point<int>> points) {
    int sum_point = 0;
    for (auto point : points) {
        // Компилятор уберёт этот if, так как знает, что
        // условие всегда истинно.
        if (true) {
            sum_point += point.x;
        } else {
            ...
        }
    }
    return sum_point;
} 
```

Теперь в ней ничего лишнего!