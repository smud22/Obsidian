Давайте вспомним пример с расчётом периметра треугольника, стороны которого могут быть заданы как числами, так и объектами класса `Side`.

```cpp
template <typename T> 
struct Triangle {
    Triangle(T a, T b, T c): a(a), b(b), c(c) {}
    
    T Perimeter() const {
        if constexpr (std::is_same_v<T, Side>) {
            // Если стороны треугольника имеют тип Side,
            // нужно использовать метод GetLength().
            return a.GetLength() + b.GetLength() + c.GetLength();
        } else {
            // Иначе достаточно просто взять их значения.
            return a + b + c;
        }
    }
    T a, b, c;
}; 
```

Чтобы корректно получить длины сторон, нужно проверить, какой тип был передан. Если мы захотим добавить в класс новые методы для работы с треугольником, нам придётся добавить проверку в каждый из них.

Избежать этого поможет **специализация** — механизм, позволяющий определить шаблон по-разному для разных типов данных.

```cpp
template <typename T> 
struct Triangle {
    Triangle(T a, T b, T c): a(a), b(b), c(c) {}
    
    int Perimeter() const {
        // Метод стал значительно проще.
        return a + b + c;
    }
    T a, b, c;
};

// Отдельный вариант Triangle для параметра Side.
// Нужно указать template<>, чтобы показать, что это
// часть шаблона.
template <> 
struct Triangle<Side> {
    Triangle(Side a, Side b, Side c): a(a), b(b), c(c) {}
    
    int Perimeter() const {
        // Проще и тут.
        return a.GetLength() + b.GetLength() + c.GetLength();
    }
    Side a, b, c;
}; 
```

Первая версия `Triangle` — это первичный шаблон, который будет работать со всеми типами, кроме `Side`. Вторая версия — специализация шаблона, предназначенная именно для `Side`.

Обратите внимание, что во втором объявлении также используется слово `template`, а нужные типы указываются в треугольных скобках после имени класса или структуры: `struct Triangle<Side>`.

У шаблонов стандартной библиотеки тоже имеются специализации. Например, у `std::vector` есть специализация `std::vector<bool>` с особенностями для более компактного хранения элементов.

Мы создали реализацию шаблона `Triangle` для конкретного шаблонного параметра — `Side`. Такой способ называется **полной специализацией шаблона**.

Если особый подход нужен не для конкретного типа, а для группы типов, можно написать вариант шаблона для каждого из них или же воспользоваться **частичной специализацией**.

Рассмотрим класс `ConstellationStar`, хранящий информацию о созвездии. Звёздную величину и название можно задать различными типами данных (`T` и `U`).

```cpp
template <typename T, typename U>
class ConstellationStar { 
    ConstellationStar(T magnitude, U name);
    ... 
}; 
```

Механизм частичной специализации позволяет создать версию класса для параметра `U`, равного `std::string`, а параметр `T` оставить шаблонным.

```cpp
// Частичная специализация: 
// U = std::string, T по-прежнему может быть любым.
template <typename T>
class ConstellationStar<T, std::string> {
    ConstellationStar(T magnitude, std::string name);
    ... 
}; 
```

Вам представлен класс `Book` и две его специализации.

```cpp
// Первичный шаблон.
template <typename T>
class Book { ... };

// Специализация 1.
template <typename T>
class Book<vector<T>> { ... };

// Специализация 2.
template <>
class Book<std::string> { ... }; 
```