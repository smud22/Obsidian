Частичная специализация позволяет различать более сложные конструкции, например классы, работающие с одним элементом или вектором элементов того же типа.

```cpp
// Звезда в созвездии может быть одиночной.
// Первый вариант шаблона.
template <typename T>
class ConstellationStar { };

// А может быть представлена звёздным скоплением.
// Второй вариант того же шаблона.
template <typename T>
class ConstellationStar<std::vector<T>> { }; 
```

В первом случае шаблонный класс `ConstellationStar` хранит информацию об одной звезде и получает единственный параметр `Т` для значения звёздной величины. Во втором случае классу нужно хранить данные о нескольких звёздах скопления, и звёздные величины задаются вектором (`std::vector<T>`).

Нужный класс будет выбран в зависимости от шаблонного аргумента.

```cpp
// Выберется первый вариант – нельзя рассмотреть
// double как std::vector<T>.
ConstellationStar<double> alpha_orionis;

// Выберется второй вариант – можно рассмотреть
// std::vector<double> как std::vector<T>.
ConstellationStar<std::vector<double>> pleiades; 
```

Специализации можно использовать при создании вспомогательных конструкций для анализа типов. Следующий пример показывает, как с их помощью реализовать проверку, является ли переменная константной.

```cpp
// Эта структура будет выбрана по умолчанию.
template<typename T>
struct IsConst {
    static constexpr bool value = false;
};

// Эта структура будет выбрана, если тип Т константный.
template<typename T>
struct IsConst<const T> {
    static constexpr bool value = true;
};

int main() {
    int a = 5;
    const int b = 10;
    
    std::cout << "a константа? - "s 
              << (IsConst<decltype(a)>::value ? "да"s : "нет"s) << std::endl;
    std::cout << "b константа? - "s 
              << (IsConst<decltype(b)>::value ? "да"s : "нет"s) << std::endl;
              
    // a константа? - нет
    // b константа? - да
} 
```