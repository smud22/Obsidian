Специализации успешно работают и для нетиповых шаблонных параметров. Например, мы можем написать функции, по-разному вычисляющие факториал:

factorial(n)=n!=1  ∗  2  ∗  3  ∗  ...  ∗  n.factorial(n)=n!=1∗2∗3∗...∗n.

Если аргумент равен 0, функция должна вернуть 1. В противном случае она должна выполнить рекурсивные вычисления, вызывая саму себя.

```cpp
// Для любого Value, кроме 0.
template<int Value>
int CountFactorial() {
    return Value * CountFactorial<Value - 1>();
}

// Для Value = 0.
template<>
int CountFactorial<0>() {
    return 1;
} 
```

Используя это свойство специализаций, можно реализовать сложные compile-time-вычисления, позволяющие получить результат ещё до выполнения программы — сразу на этапе компиляции.

В современном C++ подобная магия нужна редко: куда лучше использовать constexpr-функции. Код получается проще как для программиста, так и для компилятора.

В этом уроке вы познакомились с механизмом специализаций, позволяющим реализовать особое поведение для конкретного типа данных. Специализации можно использовать с классами — в этом случае можно указывать точные значения для всех параметров или только для некоторых. Специализации работают и с функциями, хотя в этом случае предпочтительнее перегрузки.