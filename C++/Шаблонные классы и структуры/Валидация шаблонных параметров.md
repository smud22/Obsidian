В качестве аргумента шаблону можно передать любой тип, будь то число или структура. Однако не все типы одинаковы. Одни поддерживают определённые операции, а другие нет. Сложные типы могут иметь специфичные методы и свойства, которые есть только у них. По этой причине шаблон может работать с одними типами и не работать с другими.

Рассмотрим это на примере. Класс, основанный на шаблоне `Square`, хранит стороны прямоугольника и может рассчитать его площадь — для этого передаваемый тип должен поддерживать операцию умножения. Попытка использовать шаблон с типом `std::string` вызовет ошибку компиляции:

```cpp
template<typename T>
class Square { 
public:
    Square(T a, T b) : a_(a), b_(b) { }
    
    T CountArea() {
        return a_ * b_;
    }
private:
  T a_, b_;
};

int main() {
    Square<int> sq_int{5, 4}; 
    sq_int.CountArea(); // Стороны типа int можно перемножить.
    
    Square<float> sq_float{5.5, 4.4};
    sq_float.CountArea(); // Стороны типа float тоже.
    
    Square<std::string> sq_str{"five"s, "four"s};
    sq_str.CountArea(); // Ошибка: у std::string нет операции умножения.
} 
```

Порой избежать ошибок можно благодаря ещё одной особенности C++ — «ленивости» шаблона. Компилятор будет игнорировать требования к шаблонному типу, пока они не будут задействованы напрямую. В нашем примере к ошибке приведёт не настройка шаблона на тип `std::string`, а попытка вызвать метод `CountArea`, в котором задействована операция умножения.

```cpp
Square<std::string> sq_str{"five"s, "four"s}; // На этом шаге ошибки нет.
sq_str.CountArea(); // Ошибка компиляции. 
```

Если бы мы имели дело с обычным типом, ошибка возникла бы сразу — ещё на этапе определения метода. Посмотрим на ещё один пример:

```cpp
struct Color {
    int r, g, b;
};

template<typename T>
class Gradient { 
public:
    Gradient(Color c1, Color c2) : c1_(c1), c2_(c2) {}
    
    void PrintColor() const {
        // Ошибка при компиляции шаблона: нет operator << для
        // std::ostream и Color.
       std::cout << "From "s << c1_ << " to "s << c2_ << std::endl; // Ошибка!
    }
private:
    Color c1_, c2_;
}; 
```

Если возможность ошибки зависит от шаблонного аргумента, то компилятор не будет жаловаться на код, пока вы не попытаетесь вызвать метод с ошибкой:

```cpp
template <typename T>
struct Point {
    T x, y;
};

template<typename T>
class Segment { 
public:
    Segment(Point<T> a, Point<T> b) 
            : a_(a), b_(b) {}
    
    // Печать координат концов отрезка.
    void PrintEdges() const {
        // Нет ошибки при компиляции шаблона:
        // может быть, для какого-то T есть
        // operator << (ostream&, Point<T>).
        std::cout << "A "s << a_ << ", "s;
        std::cout << "B "s << b_ << std::endl;
    }
private:
    Point<T> a_, b_;
}; 
```

Несмотря на то, что вызов метода `PrintEdges` приводит к ошибке, это не мешает создавать объекты типа `Segment<…>`.

Чтобы совсем избежать возможных ошибок, у переданного типа должны быть определены нужные операции. В следующем примере мы определили операцию вывода — и теперь можно вызывать метод:

```cpp
std::ostream& operator << (std::ostream& o, Point<int> p) {
    return o << "("s << p.x << ";"s << p.y << ")"s;
}

int main() {
    Segment<int> int_seg({0,0}, {1,1});
    // Ок! Этот метод работает для типа int.
    int_seg.PrintEdges();

    // Тоже ок, но до тех пор, пока не вызовем d_seg.PrintEdges().
    Segment<double> d_seg({0.,.0}, {1.,.1});
} 
```

В стандарте C++20 появились **концепты** — дополнение, позволяющее описывать требования к шаблонному аргументу. Они позволяют выбирать нужный шаблон и получать понятные сообщения об ошибках. Но главное — глядя на код, можно понять, что должно быть у типа, чтобы его корректно можно было подставлять в шаблон.