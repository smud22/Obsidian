В начале урока мы говорили, что при вызове шаблонных функций можно опустить явную передачу типа. Однако это возможно только в тех случаях, когда у компилятора достаточно данных, чтобы вывести его самостоятельно.

Когда вывод типов не сработает?

Прежде всего, если типы параметров нельзя однозначно определить по переданным значениям. Вернёмся к нашему примеру. Функция `Sum` принимает два аргумента одного типа. В первых двух случаях переданные значения имеют одинаковый тип, и проблемы с выводом не возникнет. В третьем примере (`Sum(10.1, 10);`) типы аргументов не совпадают, из-за чего компилятор не может однозначно определить, какой из них нужно передать шаблону. Это вызовет ошибку компиляции.

В четвёртом примере тип задан явно, и все аргументы будут приведены к нему.

```cpp
template<typename T>
T Sum(T a, T b) {
    return a + b;
}

int main() {
    Sum(10, 10); // Ок. Оба аргумента типа int.
    Sum(10.1, 11.1); // Ок. Оба аргумента типа double.
    Sum(10.1, 10); // Ошибка: выбрать int или double?
    Sum<int>(10.1, 10); // Oк: аргументы будут приведены к int.
} 
```

Вторая проблема связана с определением типа возвращаемого значения. Он может быть задан явно, как в приведённом примере (сумма двух переменных типа `T`, скорее всего, тоже будет иметь тип `Т`). Однако суммирование может работать и с разными типами, например `T` и `S`. В этом случае сказать что-то про возвращаемый тип уже сложнее.

```cpp
template<typename T, typename S>
??? Sum(T a, S b) {
    return a + b;
} 
```

Решить эту проблему можно с помощью ключевого слова `auto`. Оно позволяет избежать явного указания типа: компилятор сделает это сам, проанализировав присваиваемое значение.

```cpp
template<typename T, typename S>
auto Sum(T a, S b) {
    return a + b;
} 
```

С релизом стандарта C++20 появилась возможность объявлять шаблоны функций без ключевого слова template. Для этого в параметрах вместо типа достаточно указать `auto`. Здесь оно играет роль синтаксического сахара, делая код ещё более лаконичным.

```cpp
auto Sum(auto a, auto b) {
  return a + b;
} 
```

Вывод типа с помощью `auto` работает и с более сложными конструкциями. В следующем примере приведена функция, которая суммирует все элементы из вектора пар (отдельно `first` и `second`) и возвращает две суммы в виде новой пары. Информации о переданных параметрах будет достаточно, чтобы компилятор определил тип переменной, которой присваивается результат.

```cpp
#include <iostream>
#include <vector>

// Суммирует элементы из вектора пар.
template<typename F, typename S>
std::pair<F, S> Sum(const std::vector<std::pair<F, S>>& vec) {
    F sum_first{};
    S sum_second{};
    for(const auto& item: vec) {
        sum_first += item.first;
        sum_second += item.second;
    }
    return {sum_first, sum_second};
}

int main() {
    std::vector<std::pair<int, std::string>> my_vec = {
        {10, "Hello"s},
        {0, " "s},
        {5, "World"s},
    };
  
    // Сопоставляя 
    // std::vector<std::pair< F, S >> и
    // std::vector<std::pair<int, std::string>>,
    // компилятор определяет, что F = int, S = std::string.
    auto result = Sum(my_vec);
    assert(result.first == 15);
    assert(result.second == "Hello World"s);
} 
```

При всём этом возможности `auto` не безграничны: автоматический вывод будет работать, только если тип возвращаемого значения можно определить однозначно. В следующем примере функция с равным успехом возвращает тип `T` или `S`. Использование `auto` здесь приведёт к ошибке.