Вернёмся к примеру с вектором, заданным двумя точками. Внутри него используется структура `Point`. Сделаем и сам класс шаблоном, чтобы можно было использовать точки разных типов.

```cpp
template<typename T>
class Vector2D { 
public:
    Vector2D(Point<T> p_start, Point<T> p_end) 
        : start_(p_start), end_(p_end) {} 
    
private:
    Point<T> start_; // Точки заданного типа.
    Point<T> end_; 
}; 
```

Методы и конструкторы шаблонов принято реализовывать внутри класса. Но если всё-таки потребуется вынести реализацию, нужно будет заново указать конструкцию `template<...>`.

```cpp
template<typename T>
class Vector2D { 
public:
    Vector2D(Point<T> p_start, Point<T> p_end);
    
private:
    Point<T> start_; // Точки заданного типа.
    Point<T> end_; 
};

// Определение конструктора вне класса.
template<typename T>
Vector2D<T>::Vector2D(Point<T> p_start, Point<T> p_end) {
    this->start_= p_start;
    this->end_ = p_end;
} 
```

В шаблонных классах и структурах определение не выносят в .cpp-файл, а пишут в том же .h-файле. Это необходимо, так как при использовании шаблонного метода компилятору должен быть доступен его полный код, чтобы было возможно выполнить настройку на заданные шаблонные аргументы.

Если вынести шаблонный метод или конструктор шаблона в .cpp-файл, то вы получите ошибку линкера.

Методы всё-таки можно выносить в .cpp-файл, но тогда придётся явно указать, на какие типы требуется настройка каждого метода шаблонного класса.