В прошлом уроке мы рассмотрели случай, когда необходимость указывать тип данных может привести к дублированию кода и усложнить работу. К счастью, шаблоны могут решить эту проблему!

Вернёмся к реализации структуры `Point` для хранения координат типов `int` и `double`. Чем больше типов мы используем, тем больше копий `Point` придётся написать.

```c
struct PointInt {
  int x;
  int y;
};

struct PointDouble {
  double x;
  double y;
}; 
```

Шаблоны позволяют избежать этого описанием всего одной структуры — универсальной для всех типов.

```c
template <typename T> // Создаём шаблон с параметром Т.
struct Point {
  T x; // На место Т будет подставлен конкретный тип.
  T y;
};

int main() {
  Point<int> p_int{3, 2}; // Создаём Point с типом int.
  Point<double> p_double{1.5, 2.999}; // Создаём Point с типом double.
} 
```

Перед объявлением `Point` появилась конструкция `template <typename T>`. Она указывает на то, что далее будет объявлен шаблон (англ. template) с параметрами, перечисленными в угловых скобках `<>`. В этом случае параметр всего один — `typename T`.

Ключевое слово `typename` значит, что этот параметр является **заполнителем типа** — на его место можно подставить `int`, `double` или ваш класс. `Т` — это имя параметра. Параметрам можно давать и другие имена, однако существует соглашение, в соответствии с которым принято использовать заглавные буквы английского алфавита. При создании структуры каждый экземпляр `T` будет заменён на конкретный тип (например, `int`).

Использование шаблона похоже на вызов функции: и там и там мы передаём параметры. Однако есть два отличия:

- При вызове функции мы передаём значение или объект (например, число 5 или точку), а при использовании шаблона — тип.
- При вызове функции параметр передаётся во время работы программы, а при использовании шаблона — во время компиляции.

Иногда в коде можно встретить другую запись объявления шаблона, в котором вместо `typename` используется слово `class`: `template <class T>`. Оба варианта считаются равноправными и взаимозаменяемыми — вы можете выбрать любой и придерживаться его.

В результате мы создали **шаблон структуры**. Теперь его можно использовать как обычную структуру, передав в угловых скобках значение шаблонного аргумента для параметра `Т`. В этом случае в качестве значения передаётся тип — `int` или `double`.

С точки зрения компилятора всё работает немного сложнее. Шаблон — всего лишь обобщённое описание, в которое можно подставить аргументы, чтобы сгенерировать реальный код. На этапе компиляции из выражений `Point<int>` и `Point<double>` будут созданы следующие **шаблонные структуры**:

```c
// Так компилятор видит Point<int>.
struct Point {
  int x;
  int y;
};

// Так компилятор видит Point<double>.
struct Point {
  double x;
  double y;
}; 
```

Генерация кода по шаблону называется **настройкой** или **инстанцированием** (англ. instantiation) шаблона на тип.

Структуры `struct PointInt` и `struct PointDouble`, объявленные выше, задавали конкретный тип данных. Структура `template<typename T> struct Point` задаёт всего лишь шаблон типа — это значит, что мы не можем объявить переменную с типом `Point`. Однако с помощью шаблона можно создать множество различных типов: `Point<int>`, `Point<double>` и даже `Point<std::string>` — и объявить соответствующие им переменные.

Таким образом, проблема строгой типизации решается всё тем же способом: для каждого типа создаётся собственная копия структуры. Однако теперь компилятор делает это за нас!

Похожего результата можно достичь, используя наследие языка C — **макросы**. Они позволяют заменить фрагмент кода на псевдоним, который можно использовать в программе. Перед компиляцией все макросы автоматически заменяются на нужный код. Для их создания используется директива `#define`: сначала указывается имя макроса, а затем выражение, которое ему соответствует.

Решение проблемы с `Point` будет выглядеть следующим образом.

```c
// Создание макроса.
#define MAKE_POINT(STRUCT_NAME, TYPE) struct STRUCT_NAME { TYPE x; TYPE y;};

MAKE_POINT(PointInt, int); // Заменится на struct PointInt { int x; int y;};.
MAKE_POINT(PointDouble, double); // Заменится на struct PointDouble{ double x; double y;};.

int main() {
    PointInt pInt{1, 2};
    PointDouble pDouble{1.0, 2.6};
} 
```

Здесь `MAKE_POINT(STRUCT_NAME, TYPE)` — макрос с двумя параметрами, а `STRUCT_NAME { TYPE x; TYPE y;};` — код, который будет подставлен на его место. Так можно обойтись без явного дублирования кода.  
Макросы поддерживаются в современном C++, но считаются устаревшим инструментом. Они позволяют всего лишь заменить одну последовательность символов на другую — такой подход приводит к ошибкам, которые сложно отследить. В отличие от макросов, шаблоны не изменяют код и обрабатываются компилятором с учётом своего содержимого.