В случаях, когда нужен доступ к элементу контейнера, но не нужно знание об индексе этого элемента, существует другой способ записи цикла `for`. Он называется **range-based for**, или **цикл for по диапазону**. Записывается он следующим образом:

```cpp
std::vector<int> magic_numbers{4, 8, 15, 16, 23, 42};
// Слева от двоеточия тип и имя временной переменной.
// Справа — имя контейнера, доступ к элементам которого нужно получить.
for (int item : magic_numbers) {
    std::cout << item << std::endl;
} 
```

Такой цикл куда выразительнее: мы пробегаем по всем элементам контейнера. Доступ к индексу теперь отсутствует, но запись стала значительно короче, доступ к элементам контейнера сохранился в прежнем объёме.

Однако такой цикл позволяет итерироваться только в прямом порядке (от начала и до конца), и только последовательно — элементы идут один за другим, «перепрыгнуть» через несколько элементов не получится.

Цикл по диапазону позволяет менять значения вектора. Для этого нужно добавить одну деталь — амперсанд после имени типа.

```cpp
std::vector<int> magic_numbers{4, 8, 15, 16, 23, 42};

// Используем амперсанд, чтобы менять значения вектора.
for (int& item : magic_numbers) {
    // Поделим чётные элементы вектора на два.
    if (item % 2 == 0) {
        item /= 2;
    }
}

// Получим такие числа в векторе:
// 2, 4, 15, 8, 23, 21. 
```

Переменная `item` в этом случае становится не просто значением, а **ссылкой** на элемент вектора. Это значит, что все её изменения повлекут соответствующие изменения элементов вектора.

Также ключевое слово `auto` удобно использовать в цикле по диапазону, особенно когда тип длинный или очевидный.

```cpp
std::vector v1{1, 2, 3, 4};
// Тип контейнера известен, тип временной переменной не может быть никаким другим.
for (auto item : v1) {
    std::cout << item << std::endl;
} 
```

В этой форме также возможно использовать `&`, если есть необходимость менять значения:

```cpp
std::vector v1{1, 2, 3, 4};
// Тип контейнера известен, тип временной переменной не может быть никаким другим.
for (auto& item : v1) {
    if (item % 2 == 0) {
        item /= 2;
    }
}

// Тут будет вектор 1, 1, 3, 2. 
```