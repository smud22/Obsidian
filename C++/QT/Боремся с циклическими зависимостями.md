В графических программах, где несколько объектов взаимодействуют друг с другом, могут возникать циклические зависимости. Например, если одно поле автоматически обновляет другое, а второе в ответ обновляет первое, это может привести к бесконечному циклу изменений. Это неприятная ошибка, которая может приводить к выводу неправильных данных или зависанию программы.

Если добавить механизм, который может предотвратить циклическую зависимость, то можно предотвратить нежелательные эффекты. В качестве такого механизма используют булево поле. Рассмотрим на примере, как это работает.

Предположим, вы делаете программу для конвертации градусов Цельсия в градусы Фаренгейта и наоборот.

Мы создали такой интерфейс:

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s02_qt_basics/static-and-formatting_1.png)

Так мы реализовали слоты, отвечающие за изменение текста:

```cpp
void MainWindow::on_le_c_textChanged(const QString &str) {
    double new_val = str.toDouble() * 9/5 + 32;
    ui->le_f->setText(QString::number(new_val));
}

void MainWindow::on_le_f_textChanged(const QString &str) {
    double new_val = (str.toDouble() - 32) * 5 / 9;
    ui->le_c->setText(QString::number(new_val));
} 
```

При редактировании каждого из полей происходит изменение другого поля. Это выливается в нежелательное поведение программы:

Происходит вот что:

- Пользователь меняет текст в поле `le_f` (например, вводит число).
- Срабатывает слот, который обновляет текст в другом поле `le_c`.
- Изменение текста в `le_c` повторно вызывает слот, который снова меняет текст в `le_f`.
- Процесс повторяется бесконечно, создавая замкнутую цепочку вызовов.

Это и есть **циклическая зависимость**. Она мешает пользователю вводить текст. В нашем случае текст стабилизируется, иначе бы программа могла завершиться аварийно.

Чтобы побороть циклическую зависимость, создадим в классе окна булево поле `editing_now_` ("изменяется сейчас"). **Булево поле** — это поле, которое может принимать два возможных значения: истину или ложь. По умолчанию его значение — `false`, значит, программа не обрабатывает данные в поле. Первый слот, принявший редактирование, будет устанавливать этой переменной значение `true`. Это будет означать начало обработки события. Когда программа закончится, она вернёт полю значение `false`.

Таким образом, следующий слот видит значение `true` в поле `editing_now_` и не начинает параллельную обработку.

```cpp
void MainWindow::on_le_c_textChanged(const QString &str) {
    // Если значение true, значит, его установил другой слот.
    if (editing_now_) {
        return;
    }

    double new_val = str.toDouble() * 9 / 5 + 32;

    // Устанавливаем true, чтобы другой слот ничего не делал.
    editing_now_ = true;
    ui->le_f->setText(QString::number(new_val));

    // Устанавливаем обратно false.
    editing_now_ = false;
}

void MainWindow::on_le_f_textChanged(const QString &str) {
    // Если значение true, значит, его установил другой слот.
    if (editing_now_) {
        return;
    }

    double new_val = (str.toDouble() - 32) * 5 / 9;

    // Устанавливаем true, чтобы другой слот ничего не делал.
    editing_now_ = true;
    ui->le_c->setText(QString::number(new_val));

    // Устанавливаем обратно false.
    editing_now_ = false;
} 
```
