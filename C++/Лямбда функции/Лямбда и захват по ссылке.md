Рассмотрим ещё один пример работы со строкой. Возьмём реализацию функции деления её на части. Запятая будет в качестве разделителя. Пустые части будем игнорировать. Попробуем написать эту функцию так:

```cpp
std::vector<std::string> Split(const std::string& input_string) {
    std::vector<std::string> result;
    
    std::string cur_str;
    for(char c : input_string) {
        if (c == ',') {
            if (cur_str != "") {
                result.push_back(cur_str);
            }
            cur_str = "";
        } else {
            cur_str += c;
        }
    }
    
    return result;
} 
```

Чтобы функция ничего не теряла, добавим в её конец вставку строки:

```cpp
std::vector<std::string> Split(const std::string& input_string) {
    std::vector<std::string> result;
    
    std::string cur_str;
    for(char c : input_string) {
        if (c == ',') {
            if (cur_str != "") {
                result.push_back(cur_str);
            }
            cur_str = "";
        } else {
            cur_str += c;
        }
    }
    
    if (cur_str != "") {
        result.push_back(cur_str);
    }
    cur_str = "";
    
    return result;
} 
```

В примере дважды повторяется вот этот участок кода:

```cpp
if (cur_str != "") {
    result.push_back(cur_str);
}
cur_str = ""; 
```

Исправив ошибку, мы создали дублирование, убрать которое поможет лямбда-функция. Попробуем написать её:

```cpp
std::vector<std::string> Split(const std::string& input_string) {
    std::vector<std::string> result;
    std::string cur_str;
    
    // Объявляем лямбду.
    auto add_part = []{
        // Тут будет ошибка!
        if (cur_str != "") {
            result.push_back(cur_str);
        }
        cur_str = "";
    };
    
    // Сам алгоритм.
    for(char c : input_string) {
        if (c == ',') {
            add_part();
        } else {
            cur_str += c;
        }
    }
    
    add_part();
    
    return result;
} 
```

Исключили дублирование, но есть одна проблема: код не работает. Дело в том, что лямбда не может получить доступ к переменным функции — `cur_str` и `result`.

Мы можем исправить эту ошибку, добавив всего один символ `&` в квадратные скобки. Эти скобки не только показывают, что перед нами лямбда, но и применяются для передачи данных внутрь неё:

```cpp
// Добавили "&"  ↴
auto add_part = [&]{
    // Ошибки нет.
    if (cur_str != "") {
        result.push_back(cur_str);
    }
    cur_str = "";
}; 
```

Амперсанд означает, что будет выполняться **захват внешних переменных по ссылке**, то есть лямбда сможет менять переменные и эти изменения будут видны вызывающему коду.

Посмотрим на код лямбды через «волшебные очки», которые показывают, во что компилятор преобразует код:

```cpp
struct TempClass {
    // Захваченные переменные стали параметрами конструктора.
    TempClass(std::vector<std::string>& result, std::string& cur_str)
     : result(result), cur_str(cur_str) { }

    void operator()() const {
        if (cur_str != "") {
            result.push_back(cur_str);
            cur_str = "";
        }
    }

private:
    // Захваченные переменные появились как приватные члены.
    std::vector<std::string>& result;
    std::string& cur_str;
};
// Создаём функтор, передавая ему ссылки
// на переменные функции.
auto add_part = TempClass(result, cur_str); 
```

Используя лямбда-функцию, мы исключили дублирование и сделали реализацию более простой для восприятия.