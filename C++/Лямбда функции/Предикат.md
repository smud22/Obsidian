Функции, которые не имеют побочного эффекта, называют **чистыми функциями**. Они ничего не выводят, не меняют глобальных переменных и аргументов, не читают и не записывают файлы. Иными словами, ничего не меняют во внешнем мире, а занимаются только вычислением. Если вызвать чистую функцию повторно с теми же аргументами, то результат окажется неизменным. Использование таких функций предпочтительно, так как их поведение предсказуемо.

Если чистая функция возвращает `bool`, то её называют **предикатом**.

Примером предиката может быть проверка числа на положительное значение:

```cpp
bool IsPositive(int n) {
    return n > 0;
} 
```

Кроме обычных функций, предикатом может выступать функциональный объект, созданный на основе `std::function` или с помощью лямбда-функции.

Предикат нужен, чтобы проверять некоторое условие. Как правило, оно соответствует прилагательному или причастию. Строка может быть _пустой_, слово — _содержащим_ букву «а», а число — _отрицательным_. Всё это можно выразить предикатом.

Возьмём в качестве примера группу учеников, каждый из которых характеризуется:

- средней оценкой за полугодие;
- списком оценок;
- фамилией и именем;
- днём рождения;
- полом.

Получится структура, в которой для информации про пол ученика определим `enum`:

```cpp
enum class Gender {
    MALE, FEMALE, UNKNOWN
};

struct Student {
    double mean_score; // Средняя оценка.
    Gender gender;
    int birth_year;
    std::string first_name;
    std::string last_name;
    std::vector<int> all_scores;
}; 
```

Чтобы сохранить школьный класс, будем использовать вектор с типом `Student`:

```cpp
std::vector<Student> students = {...}; 
```

Предположим, мы хотим посчитать статистику по классу — к примеру, количество девочек:

```cpp
int CountGirls(const std::vector<Student>& students) {
    int count = 0;
    for (const auto& student: students) {
        if (student.gender == Gender::FEMALE) {
          ++count;
        }
    }
    
    return count;
} 
```

В другом месте необходимо посчитать количество отличников:

```cpp
int CountExcellent(const std::vector<Student>& students) {
    int count = 0;
    for (const auto& student: students) {
        if (student.mean_score >= 4.5) {
            ++count;
        }
    }
    
    return count;
} 
```

Если нам нужно посчитать количество учеников, родившихся зимой или получивших хоть одну двойку, то в каждой такой функции мы выполняем один и тот же порядок действий:

1. Организуем переменную для счётчика.
2. Создаём цикл прохода по всем элементам вектора, в котором при выполнении условия наращиваем счётчик.
3. Возвращаем счётчик.

Получаем дублирование практически во всём — кроме условия.

### Предикат спешит на помощь

Давайте напишем функцию, которая будет считать всё, что мы захотим. Но как передать условие в функцию? Это можно сделать в виде функционального объекта. Зададим тип функционального объекта, используя `std::function`:

```cpp
int CountSome(const std::vector<Student>& students,
               const std::function<bool (Student s)>& what_to_count) {
    int count = 0;
    for (const auto& student: students) {
        if (what_to_count(student)) {
            ++count;
        }
    }
    
    return count;
} 
```

Для каждой характеристики — свой предикат. Вместо большого количества разных функций, которые считали данные по разным заданным характеристикам, теперь нам нужна только одна функция `CountSome`. В неё передаём предикат, затем можем посчитать всё:

```cpp
int girls = CountSome(students, [](Student t){ 
  return t.gender == Gender::FEMALE;
});

int excellent_students = CountSome(students, [](Student t){ 
  return t.mean_score >= 4.5;
}); 
```

Функцию `CountSome` можно сделать более универсальной. Сейчас она принимает на вход вектор с определённым типом. Вы уже знакомы с шаблонами, поэтому можно сделать так, чтобы функция принимала вектор с любыми типами:

```cpp
template<class T>
int CountSome(const std::vector<T>& students,
              const std::function<bool (const T&)>& what_to_count) {
    int count = 0;
    for (const auto& student: students) {
        if (what_to_count(student)) {
            ++count;
        }
    }
    return count;
} 
```

Использование `std::function` требует больше ресурсов — при каждом вызове будет обращение к отдалённой памяти. Такие функции не могут встраиваться. Чтобы повысить эффективность, вместо типа `std::function<bool (const T&)>` можно использовать шаблонный аргумент. Он не так выразителен, но зато более эффективен:

```cpp
template<class T, class Predicate>
int CountSome(const std::vector<T>& students,
              const Predicate& what_to_count) {
    int count = 0;
    for (const auto& student: students) {
        if (what_to_count(student)) {
            ++count;
        }
    }
    return count;
} 
```

Глядя на сигнатуру, нельзя понять, какие параметры принимает предикат. Зато это хорошо будет знать компилятор: для каждого предиката он будет компилировать функцию заново. А значит, сможет применить все оптимизации, как если бы мы скопировали весь код `CountSome`, указав вместо абстрактного предиката конкретную функцию.

### Алгоритмы и предикаты

Мы написали функцию `CountSome`. Оказывается, подобная функция уже есть в C++! Это `std::count_if` из стандартных алгоритмов, для использования которых необходимо подключить библиотеку `#include <algorithm>`. Отличие `std::count_if` от нашей функции в том, что она принимает не вектор, а диапазон, заданный двумя итераторами (вы познакомитесь с ними в следующем спринте). Пока что мы будем использовать диапазон, применяя методы `begin` и `end`, что соответствует диапазону от начала и до конца контейнера:

```cpp
int girls = std::count_if(students.begin(), students.end(), [](Student t){ 
    return t.gender == Gender::FEMALE;
}); 
```

Если в качестве предиката используется обычная функция, то она должна соответствовать требованиям, применимым к предикатам. То есть принимать в качестве параметра один объект и возвращать тип `bool`. При работе с функцией в качестве предиката используется лишь её именование:

```cpp
// Функция-предикат.
bool IsGirl(Student student) {
    return student.gender == Gender::FEMALE;
}

...
// Использование:
int girls = std::count_if(students.begin(), students.end(), IsGirl); 
```

Составьте правильное выражение, чтобы применить предикат `auto predicate = [](int x){return x % 2 == 0;}` для проверки вектора чисел `container`.

У алгоритма `count_if` есть напарник — `count`, который может посчитать количество элементов контейнера, равных определённому. Например, количество двоек в векторе или букв `'S'` в строке. В этом случае в качестве третьего параметра указывается не предикат, а значение, которое алгоритм будет искать в последовательности. В нашей структуре, которая характеризует группу учеников, есть поле с оценками `all_scores`. Так как этот контейнер не хранит сложных данных, то достаточно использовать `count`. Посчитаем количество пятёрок:

```cpp
// Возьмём определённого студента из вектора.
Student student = students[num];

// Прочитаем контейнер с его оценками.
const std::vector<int>& scores = student.all_scores;

// Используем std::count для подсчёта пятёрок:
int fives_count = std::count(scores.begin(), scores.end(), 5); 
```

Если нам понадобится узнать, есть ли в оценках двойка, то можем также использовать `std::count`. Если двоек нет, то результатом алгоритма будет ноль.

Для проверки наличия элемента достаточно проходить контейнер до первого вхождения нужного элемента. `std::count` будет всегда идти до конца и поэтому неэффективен для такой задачи. Лучше выбрать `std::find`:

```cpp
// Используем std::find для проверки наличия двоек:
/*какой-то тип*/ is_exist = std::find(scores.begin(), scores.end(), 2); 
```

Если `std::count` возвращает тип `int`, то с `std::find` ситуация сложнее. Он не просто отвечает, есть ли такой элемент в последовательности (для чего бы подошёл тип `bool`), а возвращает **итератор**, указывающий на нужный элемент. Либо `scores.end()`, если элемент не найден:

```cpp
auto is_exist = std::find(scores.begin(), scores.end(), 2);
if(is_exist == scores.end()) {
  std::cout << "Двоек нет!" << std::endl;
} 
```

Мы рассмотрели проверку контейнера на наличие элемента. Если понадобится реализовать более сложное условие (например, найти чётное число или яркий цвет в списке цветов), то нужно использовать другой алгоритм с постфиксом `_if` — `std::find_if`. Как и `std::count_if`, ему нужен предикат в качестве третьего параметра.

В предикатах можно использовать любые вычисления, в том числе алгоритмы. Например, проверим, есть ли в классе двоечник:

```cpp
auto first_bad_student = std::find_if(
    students.begin(), students.end(), [](Student t){ 
        // Проверяем, есть ли в оценках двойка.
        auto pos = std::find(t.scores.begin(), t.scores.end(), 2);
        return t.scores.end() != pos;
    }
);

if (first_bad_student == students.end()) {
    std::cout << "Двоечников нет!" << std::endl;
} 
```

Так же как и `std::find`, алгоритм вернёт итератор на первый элемент, который соответствует условию.

Кроме подсчёта и проверки наличия элементов, предикаты могут использоваться для **фильтрации** их последовательности, то есть удаления элементов с определёнными характеристиками. Например, так можно удалить пустые строки из вектора:

```cpp
std::vector<std::string> v_strings = {"Предикат", "", "нужен", ", чтобы", "фильтровать, ", "искать, ", "", "", "проверять", ""};

// Сохраняем предикат проверки строки на пустоту.
auto is_empty = [](const std::string& s){ 
    return s.empty();
};

// Удаляем из вектора все пустые строки.
std::erase_if(v_strings, is_empty);

// Выводим результат.
for (auto str : v_strings) {
    std::cout << str << " ";
}
// Результат: "Предикат нужен, чтобы фильтровать, искать, проверять". 
```

Пустые строки можно удалить проще. Подойдёт `erase`, который удалит строки, равные `""`:

```cpp
std::vector<std::string> v_strings = {"Предикат", "", "нужен", ", чтобы", "фильтровать, ", "искать, ", "", "", "проверять", ""};
std::erase(v_strings, ""); 
```

Но `erase` не подойдёт, если нужно, например, удалить строки без буквы «а»:

```cpp
std::vector<std::string> v_strings = {"Предикат", "", "нужен", ", чтобы", "фильтровать, ", "искать, ", "", "", "проверять", ""};

auto has_no_a = [](const std::string& s){ 
    return s.find("а") == std::string::npos;
};

// Удаляем строки без "а".
std::erase_if(v_strings, has_no_a);

// Результат: "Предикат фильтровать, искать,". 
```

Алгоритм `std::erase_if` работает только со стандарта C++20, до этого использовался `std::remove_if`, который переставляет удаляемые элементы в конец и возвращает итератор на первый из них. После его работы нужно вызвать метод `erase()` для окончательного удаления элементов, которые оказались в «хвосте»:

```cpp
std::vector<std::string> v_strings = {"Предикат", "", "нужен, чтобы", "фильтровать,", "искать,", "", "", "проверять", ""};

auto is_empty = [](const std::string& s){ 
    return s.empty();
};

// Новый последний элемент:
auto new_end = std::remove_if(v_strings.begin(), v_strings.end(), is_empty);

// Удаляем "хвост" вектора.
v_strings.erase(new_end, v_strings.end());

// Выводим результат.
for(auto str : v_strings) {
    std::cout << str << std::endl;
} 
```