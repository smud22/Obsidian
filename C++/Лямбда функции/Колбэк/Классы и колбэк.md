Функции обратного вызова можно использовать не только в качестве аргументов функций, но и при организации взаимодействия классов. Рассмотрим как пример проект программы, задача которой — отслеживать состояние компьютера: температуру процессора и количество свободной памяти на диске.

В случае превышения лимита температуры или при количестве памяти меньше минимального надо зафиксировать событие в журнале событий. Разделим функционал по трём классам — сканер `Scanner`, логгер `Logger` и основной класс `StateComputer`.

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s03_advanced_cpp/shceme_lambda.png)

_Диаграмма классов_

Задача сканера — следить за двумя характеристиками. У него есть два публичных метода, которые позволяют установить функции обратного вызова. Он будет вызывать их при событии превышения критического уровня температуры и недостаточном количестве памяти:

- `SetCallbackTemperature(...)` — сохраняет функцию в поле класса `callback_temperature_`;
- `SetCallbackMemory(...)` — записывает в поле `callback_memory_`.

В коде это выглядит так:

```cpp
// Сохраним в поля класса выполняемые функции.
void Scanner::SetCallbackTemperature(TemperatureCallback callback) {
    callback_temperature_ = callback;
}

void Scanner::SetCallbackMemory(MemoryCallback callback) {
    callback_memory_ = callback;
} 
```

Кроме того, в сканере будут два приватных метода, которые вызываются при изменении температуры и количества памяти:

```cpp
Scanner::UpdateTemperature(int new_temp) {
    const int max_temperature = 100;
    
    int old_temp = temperature_;
    temperature_ = new_temp;
    
    if (temperature_ >= max_temperature) {
        // Вызываем функцию обратного вызова, передавая ей параметры:
        callback_temperature_(old_temp, new_temp);
    }
}

Scanner::UpdateMemory(double new_memory_consumption) {
    const double min_memory_percent = 5;
    memory_consumption_ = new_memory_consumption;
    
    if (100 - memory_consumption_ <= min_memory_percent) {
        // Вызываем функцию обратного вызова, передавая ей параметр:
        callback_memory_(memory_consumption_);
    }
} 
```

Сканеру не надо знать, что будет сделано в случае возникновения события. Так как за поведение отвечает класс `StateComputer`, который должен иметь доступ к двум классам:

- `Scanner` — для установки функций обратного вызова.
- `Logger` — для записи информации о произошедшем событии в журнале.

Вызов метода `write()`, который является методом класса `Logger`, будет внутри лямбда-функции. Вот пример функции обратного вызова по отслеживанию температуры:

```cpp
auto callback_temp = [&](double prev_temp, double new_temp){
    logger.write("Critical temperature: " + std::to_string(new_temp));
}; 

scanner.SetCallbackTemperature(callback_temp); 
```

Таким образом, мы рассмотрели взаимодействие классов — детектора `Scanner`, который сканировал состояние, и основного класса `StateComputer`, который использовал детектор. В результате получилось связать работу нескольких независимых классов. Каждый из них отвечает за выполнение определённых задач. Сможете распределить задачи между классами?