Вы уже знаете, что тип результата лямбда-функций определяется автоматически, то есть нет необходимости указывать его при создании. Кроме этого, `auto` может быть использован вместо типа параметра. Такой вариант называют **универсальной лямбда-функцией**. Например, сложение двух объектов:

```cpp
auto sum = [](auto a, auto b){ return a + b; }; 
```

Чтобы сложить два числа, напишем:

```cpp
std::cout << sum(1, 2) << std::endl; 
```

Всё отлично сработало и вывело ожидаемый результат — 3. Теперь передадим две строки:

```cpp
std::cout << sum("Привет, ", "универсальная лямбда!") << std::endl; 
```

Получим ошибку `error: invalid operands of types 'const char*' and 'const char*' to binary 'operator+'`. Так как тип `auto`, то компилятор по умолчанию привёл текстовую строку к типу `const char*`, у которого не определена операция сложения.

Так выглядят все три способа:

```cpp
// Подключение literals для использования s-литерала.
using namespace std::literals;
auto sum = [](auto a, auto b){ return a + b;};

// Использование литералов для приведения к std::string.
sum("Привет, "s, "универсальная лямбда!"s);

// Использование конструктора std::string.
sum(std::string{"Привет, "}, std::string{"универсальная лямбда!"});

// Создание переменных с типом std::string.
std::string hi{"Привет, "};
std::string lambda{"универсальная лямбда!"};
sum(hi, lambda); 
```

Такое поведение похоже на шаблонные функции, но в коде нет угловых скобок. На самом деле они спрятаны в функторе, который генерирует компилятор для лямбда-функции, если встречает слово `auto` в параметре:

```cpp
template<typename T, typename U>
auto operator()(T a, U b) const {
    return a + b;
} 
```

Для каждой `auto`-переменной свой шаблонный тип. То есть можно передать два разных типа для сложения.

Если универсальных лямбда-функций недостаточно, можно использовать шаблонную лямбду. Для этого нужно добавить угловые скобки после квадратных. Так выглядит пустая шаблонная лямбда-функция:

```cpp
auto template_lambda = []<>(){}; 
```

Угловые скобки позволяют явно указать, с какими шаблонными параметрами будет работать функция. Например, так можно задать одинаковый тип для двух аргументов:

```cpp
auto template_lambda = []<typename T>(T a, T b){ return a + b;};
auto result = template_lambda(1, 2.1); 
```

При таком вызове уже на этапе компиляции получим ошибку `no match for call to '(main()::) (int, double)'`, которая говорит, что нет функции для сложения двух разных типов.

Но количество скобок можно сократить:

- можно убирать угловые (`<>`) или круглые скобки (`()`), если они пустые;
- нельзя убирать квадратные (`[]`) и фигурные скобки (`{}`).

Вот пример лямбда-функции без лишних скобок:

```cpp
auto hello_lambda = []{
    std::cout << "Hello everyone! I'm mini lambda!" << std::endl;
};
hello_lambda(); 
```