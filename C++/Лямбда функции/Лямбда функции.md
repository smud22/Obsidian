### Создание локальных функций

Возьмём для примера программу, реализующую хор зверушек. У каждого солиста своя партия. Напишем код, где для каждого исполнителя есть отдельная функция:

```cpp
void CatSing() {
  cout << "Мяу, Мяу, Мяу" << endl;
}

void DogSing() {
  cout << "Гав, Гав, Гав" << endl;
}

void DuckSing() {
  cout << "Кря, Кря, Кря" << endl;
}

int ChoralSing() {
  CatSing();
  DogSing(); 
  DuckSing()
} 
```

Нам понадобилось три функции, которые очень похожи и используются только в `ChoralSing`. Чтобы не засорять глобальное пространство имён, мы бы хотели перенести их внутрь `ChoralSing`. Но напрямую разместить одну функцию внутри другой нельзя. Зато можно внутри функции разместить класс или структуру. Такой класс будет называться **локальным**, из него можно сделать функтор, поместив в него `operator()`:

```cpp
int ChoralSing() {
    // Структура внутри функции.
    // Она называется локальной.
    struct AnimalSong {
        void operator()(std::string x) const {
            std::cout << x << ", " << x << ", " << x << std::endl;
        };
    };
    
    AnimalSong song;
    song("Мяу");
    song("Гав");
    song("Кря");
} 
```

Стало лучше — мы смогли убрать три функции и сократить количество кода. Но можно сделать ещё лучше. В C++ есть синтаксический сахар для функтора внутри функции. Этот объект называется **лямбда-функцией**:

```cpp
int ChoralSing() {
    // Лямбда-функция записывается в переменную song.
    /* какой-то тип */ song = [](std::string x) {
      std::cout << x << ", " << x << ", " << x << std::endl;
    };
    
    // Трижды вызовем лямбда-функцию.
    song("Мяу"); 
    song("Гав");  
    song("Кря"); 
} 
```

Под капотом компилятор создаёт структуру. Тип её нам неизвестен. Но знать его не обязательно, ведь можно написать `auto`:

```cpp
int ChoralSing() {
    // Пишем auto — компилятор сам выведет тип.
    auto song = [](std::string x) {
        std::cout << x << ", " << x << ", " << x << std::endl;
    };

    // ...
} 
```

Чтобы записать лямбда-выражение, понадобилось три вида скобок:

- Пустые квадратные `[]` — основной признак лямбда-функции.
- Круглые с параметрами, как у обычной функции, `(std::string x)`.
- Фигурные — с телом функции `{...}`.

### А что вернём?

В лямбда-функциях тип возвращаемого значения выводится автоматически на основании оператора `return`:

```cpp
auto make_song_text = [](std::string x) {
    using namespace std::literals;
    // На основании этого return компилятор
    // поймёт, что лямбда возвращает std::string.
    return x + ", "s + x + ", "s + x;
};

// Вызываем лямбда-функцию, получая результат.
std::string my_text = make_song_text("Мяу");
assert(my_text == "Мяу, Мяу, Мяу"); 
```

Но есть возможность указать тип явно. Он указывается после стрелки (символов `->`) между списком параметров и телом лямбды:

```cpp
// Указываем тип явно: лямбда принимает
// std::string и возвращает его же.
auto make_song_text = [](std::string x) -> std::string {
    using namespace std::literals;
    return x + ", "s + x + ", "s + x;
}; 
```

**Сохранение в другую переменную**

Лямбда-функция — это выражение. Их можно свободно писать в любом месте внутри функции. Значение этого выражения сохраняется в переменную. С лямбда-функцией можно делать то же, что и с любым другим объектом: передавать в функцию как аргумент, возвращать из функции, пересохранять в другую переменную:

```cpp
// Объявили:
auto song = [](std::string x) {
    std::cout << x << ", " << x << ", " << x << std::endl;
};

// Сохранили в другую переменную:
auto save_song = song; 
```

В прошлом уроке вы познакомились с классом-обёрткой `std::function`, в который мы сохраняли обычные функции и функторы.

Добавим в этот список теперь и лямбда-функции. Напомним: чтобы записать объект в обёртку `std::function`, необходимо совпадение сигнатур — возвращаемый тип и входные данные должны быть идентичными.

```cpp
// Создадим лямбда-функцию.
auto lambda_song = [](std::string x) {
    std::cout << x << ", " << x << ", " << x << std::endl;
};

// Сохраним в std::function.
std::function<void(std::string x)> song = lambda_song;
    
// Вызовем.
song("До-ми-соль"s); 
```

