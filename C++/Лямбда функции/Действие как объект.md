Предположим, вам необходимо разработать программу для кофейни, где подают разные напитки: кофе, чай, какао.

Для этого создадим три функции:

```cpp
using OrderId = size_t;

int MakeCoffee(OrderId order_number) {
  // Приготовить кофе.
  // Вернуть стоимость приготовленного кофе.
}

int MakeCocoa(OrderId order_number) {
  // Приготовить какао.
  // Вернуть стоимость приготовленного какао.
}
  
int MakeTea(OrderId order_number) {
  // Приготовить чай.
  // Вернуть стоимость приготовленного чая.
} 
```

Официант получает заказ, потом идёт к бариста и говорит, что надо приготовить. Создадим `enum` для типов напитков:

```cpp
enum class DrinkType {
  kCoffee,
  kCocoa,
  kTea
}; 
```

Листок заказа официанта можно представить как вектор с данными (типы напитков):

```cpp
std::vector<DrinkType> drinks; 
```

Напишем функцию, которая примет на вход номер заказа и этот вектор, затем будет выполняться приготовление нужных напитков:

```cpp
int DoOrder(OrderId order_number, const std::vector<DrinkType>& order) {
    int cost = 0;
    for (DrinkType type_drink : order) {
        switch (type_drink) {
        case DrinkType::kCoffee: 
          cost += MakeCoffee(order_number);
          break;
        case DrinkType::kCocoa:
          cost += MakeCocoa(order_number);
          break;
        case DrinkType::kTea:
          cost += MakeTea(order_number);
          break; 
        }
    }
    return cost;
} 
```

Сейчас меню неразнообразное — и количество `case` невелико. Но если добавлять другие напитки, код будет разрастаться, становясь всё более громоздким. Хорошо было бы сразу размещать в контейнер действия, которые можно запустить на исполнение. Сейчас вы уже умеете сохранять числа и строки в переменные, теперь надо научиться сохранять действие и работать с этим созданным объектом. Такое сохранённое действие называется **функциональным объектом**.

Представим, что у нас уже есть такой объект, который работает как выполняемое действие. Тогда код сократится и станет гораздо компактнее:

```cpp
int DoOrder(OrderId order_number, const std::vector<CookAction>& order) {
  int cost = 0;
  for (CookAction action : order) {
    // Используем переменную action, как если
    // бы она была функцией.
    cost += action(order_number);
  }
  
  return cost;
} 
```

Разберёмся, что скрывается под нашим типом `CookAction`. Он связан с созданием функционального объекта, который проще всего получить из имеющейся обычной функции. Но нельзя просто присвоить в переменную объявление функции:

```cpp
// Так не сработает.
auto action = MakeCoffee(OrderId); // Ошибка!
int cost = action(3); 
```

Код не скомпилируется. Чтобы сохранить функцию в переменную, используется обёртка `std::function`. Это шаблон класса, который позволяет использовать функцию как значение. Значение можно записать в переменную или добавить в вектор. В качестве шаблонного параметра `std::function` принимает сигнатуру функции, которую может сохранить:

```cpp
// Теперь CookAction – функция,
// принимающая OrderId и возвращающая int.
using CookAction = std::function<int (OrderId)>;

int DoOrder(OrderId order_number, const std::vector<CookAction>& order) {
  int cost = 0;
  for (CookAction action : order) {
    cost += action(order_number);
  }
  
  return cost;
} 
```

Объект типа `std::function<...>` можно сконструировать из обычной функции. При этом мы не вызываем функцию, то есть не указываем её аргументы. Пишем только имя. Так, например, можно вызвать `DoOrder`, передав в контейнере имена функций, которые надо будет вызвать для выполнения заказа:

```cpp
// Кофе и два чая в заказ 15.
DoOrder(15, {MakeCoffee, MakeTea, MakeTea}); 
```

Вы могли заметить, что мы указали сигнатуру в качестве шаблонного параметра. На самом деле сигнатура здесь — это тип, который описывает использование функции. Он описывает функциональный объект, который получается из обычной функции. В отличие от `std::function`, нельзя создать переменную такого типа или сложить объекты в вектор. Таким образом, `std::function` добавляет больше возможностей примитивному функциональному типу.

Обобщённую схему объявления переменной типа `std::function` можно представить так:

```cpp
std::function<возвращаемый_тип(параметры функции)> имя_переменной; 
```

Важно, что описанная сигнатура должна быть идентична функции, которую вы будете сохранять в этот объект. Это напоминает присваивание обычных переменных. К примеру, следующий код не скомпилируется, потому что типы не совпадают:

```cpp
int number;
std::string str = "";
number = str; 
```

Даже если функции делают разные операции, но имеют одинаковые сигнатуры, их можно будет записать в эту переменную. Рассмотрим пример. Создадим функциональный объект, принимающий на вход `const std::string&` и возвращающий тип `void`:

```cpp
std::function<void(const std::string&)> action; 
```

Так как внутри угловых скобок `std::function` находится `void(const std::string&)`, то корректны те варианты, которые принимают на вход одну переменную с типом `const std::string&` и возвращают тип `void`.

Используем правильные варианты функций для присваивания их в функциональные объекты, которые затем можно вызвать. Обратите внимание: для работы с `std::function` надо подключить `#include <functional>`.

```cpp
#include <functional>
#include <iostream>

void SayHello(const std::string& name) {
    std::cout << "Привет, " << name<< "!" << std::endl;
}

void WriteMessage(const std::string& message) {
    std::cout << message << std::endl;
}

void PrintReversed(const std::string& text) {
    // Простейший способ перевернуть текст.
    std::cout << std::string(text.rbegin(), text.rend()) << std::endl;
}

int main() {
  // Объявление.
  std::function<void(const std::string&)> action;
  
  // Присвоим и вызовем функцию SayHello.
  action = SayHello;
  action("Студент Практикума");
  
  // Теперь изменим выполняемое действие, присвоив функцию WriteMessage.
  action = WriteMessage;
  action("Это урок об изучении функциональных объектов");
  
  // Ещё раз поменяем выполняемое действие.
  action = PrintReversed;
  action("Раз два три четыре пять");
} 
```

Но вернёмся к нашему типу `CookAction`, который мы передали как тип создаваемого вектора действия. Под этим именем как раз скрывается `std::function` с описанной сигнатурой функции `int (OrderId)`, то есть `std::function<int(OrderId)>`. Чтобы не писать столь сложный тип, можно упростить, используя `using`:

```cpp
using CookAction = std::function<int(OrderId)>; 
```

Теперь можно создать вектор для хранения объектов с типом `CookAction`:

```cpp
using CookAction = std::function<int(OrderId)>;
std::vector<CookAction > order;

order.push_back(MakeCoffee);
order.push_back(MakeCocoa); 
```

Теперь мы можем выполнить действия, которые поместили в контейнер. Для этого используем цикл `for`:

```cpp
for (CookAction action : order) {
  cost += action(order_number);
} 
```