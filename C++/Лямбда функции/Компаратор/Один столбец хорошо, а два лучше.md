Часто мы сортируем экземпляры структуры или класса по некоторому параметру (например, задачи по времени их начала). В этом случае не ясно, как быть, если время начала у двух задач совпадает. Мы можем выбрать другой параметр и сортировать по нему при совпадении первого. Такая сортировка вам уже знакома, она называется лексикографической. Сделаем такой компаратор:

```cpp
bool CompareTimeAndName(const Task& lhs, const Task& rhs) {
    // Если время первой задачи меньше, то она идёт раньше (true).
    if (lhs.time_start < rhs.time_start) {
        return true;
    }
    // Если время первой задачи больше, то она идёт позже (false).
    if (lhs.time_start > rhs.time_start) {
        return false;
    }
    // Остался случай, когда время совпадает, — сравниваем имя.
    return lhs.name < rhs.name;
}; 
```

Код получился довольно сложным, но его можно упростить. Лексикографическое упорядочивание уже реализовано для `std::tuple`, воспользуемся этим:

```cpp
bool CompareTimeAndName(const Task& lhs, const Task& rhs) {
    // Сравниваем два std::tuple.
    return std::tuple(lhs.time_start, lhs.name) < 
           std::tuple(rhs.time_start, rhs.name);
}; 
```

Создание `std::tuple` вызывает копирование. Эффективнее использовать `std::tie`:

```cpp
bool CompareTimeAndName(const Task& lhs, const Task& rhs) {
    // tie создаст tuple без копирования.
    return std::tie(lhs.time_start, lhs.name) < 
           std::tie(rhs.time_start, rhs.name);
}; 
```

Основной недостаток `std::tie` — он не может работать с временными значениями:

```cpp
Point point;

// Ошибка! Временное значение в tie.
auto tie = std::tie(point.x + point.y, point.x - point.y);

// Ок.
int sum = point.x + point.y;
int diff = point.x - point.y;
auto tie = std::tie(sum, diff);
 
```

Если сравнение — неотъемлемая часть структуры, можно для удобства создать метод для построения `std::tuple`:

```cpp
struct Task {
    std::string name;
    Time time_start;
    
    auto AsTuple() const {
        return std::tie{time_start, name};
    }
};

bool CompareTimeAndName(const Task& lhs, const Task& rhs) {
    // tie создаст tuple без копирования.
    return lhs.AsTuple() < rhs.AsTuple();
}; 
```