Существует множество алгоритмов сортировки, но вам не нужно их реализовывать, так как в C++ уже есть готовая функция — `std::sort`. Она входит в библиотеку стандартных алгоритмов, которая подключается через `#include <algorithms>`.

Чтобы отсортировать вектор, нужно вызвать его методы `begin()` и `end()` и передать результаты в качестве параметров `std::sort`. Это будет означать сортировку от начала (англ. `begin`) до конца (англ. `end`). Например, так можно отсортировать вектор чисел:

```cpp
std::vector<int> int_vector{10, 5, -3, -12, 5};
    
// Отсортируем числа:
std::sort(int_vector.begin(), int_vector.end());
// Результат вывода на печать: -12, -3, 5, 5, 10. 
```

Или, например, вектор строк:

```cpp
std::vector<std::string> string_vector = 
    {"C++", "is", "the", "best", "programming", "language", 
     "in", "the", "World"};

// Отсортируем вектор от начала до конца.
std::sort(string_vector.begin(), string_vector.end());

// После сортировки слова встанут в таком порядке:
// C++ World best in is language programming the the.  
```

Из этого примера вы можете увидеть, что сортировка выполняется по возрастанию: от меньшего элемента к большему. Для строк выполняется лексикографическое сравнение по порядку в таблице ASCII. Не стоит забывать, что заглавные и строчные буквы имеют разное значение в таблице ASCII. Как ни парадоксально, заглавная буква считается меньшим элементом, чем аналогичная строчная. В результате сортировки строки выстроились по алфавиту, но слова с заглавных букв идут в начале.

А если мы хотим отсортировать в другом порядке? От большего к меньшему или по длине строки?

В этом случае нужно ввести другое **отношение порядка** — условие, при котором один элемент нужно располагать раньше другого при сортировке. Например, для сортировки от меньшего к большему мы использовали отношение порядка «меньше». Меньший элемент следует расположить раньше большего. Кодом это выражается так:

```cpp
auto less = [](auto lhs, auto rhs) {
    // Вернуть true, если lhs меньше rhs.
    return lhs < rhs;
}; 
```

Такой предикат сравнивает два элемента и возвращает `bool`. Его называют **компаратором**. Компаратор всегда работает с двумя объектами и в качестве результата возвращает тип `bool`. Используемый компаратор влияет на то, какой порядок в результате получится.

Компаратор — не любая функция. Он должен обладать свойствами математического порядка, такими как **транзитивность**: если элемент А меньше элемента В, а элемент В меньше элемента С, то должно выполняться условие, что А меньше С.

Возьмём для примера порядок, который сравнивает только длины строк. Он будет располагать левее более короткую строку. На языке кода это выглядит так:

```cpp
// Компаратор проверяет, что длина первой строки 
// (lhs) меньше длины второй строки (rhs).
// Сортировка по такому компаратору будет начинать с коротких строк.
[](std::string lhs, std::string rhs) {
    return lhs.size() < rhs.size();
} 
```

Чтобы использовать компаратор при сортировке, его передают в качестве третьего параметра в функцию `std::sort`. Например, упорядочим числа по убыванию:

```cpp
std::vector<int> int_vector = {1, 9, 3, 17, 26, 5, 14};
auto comparator = [](int lhs, int rhs){ 
    // Компаратор определит, должно ли lhs идти раньше rhs.
    // Сортировка по убыванию, значит, раньше идёт большее число.
    // Возвращаем true, если lhs больше.
    return lhs > rhs; 
};

// Вывод на печать до сортировки:
// 1, 9, 3, 17, 26, 5, 14

std::sort(int_vector.begin(), int_vector.end(), comparator);

// Вывод на печать:
// 26, 17, 14, 9, 5, 3, 1 
```

В случае несложного компаратора его можно не записывать в переменную, а сразу передать параметром в `std::sort`:

```cpp
std::sort(int_vector.begin(), int_vector.end(), 
    [](int lhs, int rhs){ return lhs > rhs; }
); 
```

Можно вовсе не писать этот компаратор, а воспользоваться уже готовым `std::greater`, который выполняет сортировку по убыванию:

```cpp
// Так как std::greater – тип, а sort принимает объект, нужно
// поставить пустые скобки, чтобы создать объект типа: std::greater{}.
std::sort(int_vector.begin(), int_vector.end(), std::greater{}); 
```

Если компаратор не указывать, то по умолчанию будет использоваться `std::less`. Он сортирует элементы в порядке возрастания.

Таким образом, если для сортировки достаточно использовать стандартные `std::greater` и `std::less`, то можно сэкономить время и не создавать собственный компаратор.