Пока мы рассматривали простые типы, но чаще всего приходится работать с более сложными объектами, которые представлены, к примеру, структурами. Рассмотрим структуру, которая описывает запланированное домашнее дело или рабочую задачу:

```cpp
struct Time {
    int hour; // Часы.
    int min;  // Минуты.
    auto operator<=>(Time) const = default; // Операция сравнения.
};

struct Task {
    std::string name;
    Time time_start;
}; 
```

У нас есть список из нескольких дел, которые размещены в неупорядоченном виде в векторе. Наша задача — составить из них расписание:

```cpp
Task task1 = {
    .name = "Выполнить задание по С++", 
    .time_start = {.hour = 9, .min = 15}};
Task task2 = {
    .name = "Тренировка в фитнес-клубе", 
    .time_start = {.hour = 20, .min = 40}};
Task task3 = {
    .name = "Встретиться с друзьями", 
    .time_start = {.hour = 18, .min = 10}};
Task task4 = {
    .name = "Записать новый рилс", 
    .time_start = {.hour = 20, .min = 25}};
Task task5 = {
    .name = "Послушать вебинар", 
    .time_start = {.hour = 17, .min = 10}};

std::vector<Task> tasks = {task1, task2, task3, task4, task5}; 
```

Чтобы отсортировать список дел по времени, используем компаратор, сравнивающий время:

```cpp
auto compare_time = [](const Task& lhs, const Task& rhs){
    return lhs.time_start < rhs.time_start;
}; 
```

Применим созданный компаратор к списку дел:

```cpp
sort(tasks.begin(), tasks.end(), compare_time); 
```

Теперь задачи будут отсортированы по времени корректно! Выведем расписание дел на печать:

```cpp
09:15 Выполнить задание по С++
17:10 Послушать вебинар
18:10 Встретиться с друзьями
20:25 Записать новый рилс
20:40 Тренировка в фитнес-клубе 
```

Кроме лямбда-функций, в `std::sort` можно использовать и обычные. Преобразуем наш компаратор и сделаем из него именованную функцию:

```cpp
bool CompareTime(const Task& lhs, const Task& rhs){
    return lhs.time_start < rhs.time_start;
}; 
```

Чтобы использовать функцию, надо передать третьим параметром в `std::sort` только её наименование:

```cpp
sort(tasks.begin(), tasks.end(), CompareTime); 
```

Другой способ упорядочить дела — по названию в алфавитном порядке. Передадим в качестве компаратора лямбда-функцию, которая сравнивает поля `name` двух экземпляров структуры `Task`:

```cpp
std::sort(tasks.begin(), tasks.end(), [](const Task& lhs, const Task& rhs){
    return lhs.name < rhs.name;
}); 
```

Такая сортировка будет учитывать регистр символов, и строки, начинающиеся с прописных букв, будут идти в начале.

Упорядочить строки без учёта регистра поможет Qt — используем функцию `QString::compare`:

```cpp
std::vector<QString> strings = {"Яблоко", "банан", "Апельсин", "арбуз"};
std::sort(strings.begin(), strings.end(), 
    [](const QString& lhs, const QString& rhs){
        // Qt::CaseInsensitive задаёт регистронезависимое сравнение.
        return QString::compare(lhs, rhs, Qt::CaseInsensitive) < 0;
    }
);

// Получим: "Апельсин", "арбуз", "банан", "Яблоко".
// При обычной сортировке получится "Апельсин", "Яблоко", "арбуз", "банан". 
```

Обратите внимание на код — в нём мы сравнили результат вызова с нулём. Это связано с особенностью функции `QString::compare`, которая может возвращать значение одного из трёх типов:

- отрицательное число, если `lhs` меньше `rhs`;
- ноль, если `lhs == rhs`;
- положительное число, если `lhs` больше `rhs`.

Таким образом:

- `QString::compare(lhs, rhs, …) < 0` означает, что `lhs < rhs`;
- `QString::compare(lhs, rhs, …) > 0` означает, что `lhs > rhs`;
- `QString::compare(lhs, rhs, …) == 0` означает, что `lhs == rhs`.

При этом сравнение выполняется нужным способом: с учётом регистра или без учёта регистра, в зависимости от третьего параметра.