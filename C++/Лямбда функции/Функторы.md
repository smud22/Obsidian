Вы увидели, как сохранить в `std::function` функцию. Но можно сохранить и другой объект. Главное требование — возможность использовать круглые скобки: `object(...)`. Такие объекты `object` называют функторами. Можно сделать свой класс функтором, если определить в нём операцию круглые скобки — `operator()`.

Создадим простой функтор, который возвращает `void` и имеет параметр типа `const std::string&`:

```cpp
class Action {
public:
  void operator()(const std::string& text) {
    std::cout << "Печать текста: '" 
              << text << "'" << std::endl;
  }
}; 
```

Так же, как при работе со структурами и классами, вам необходимо:

- создать экземпляр;
- вызвать метод класса или структуры.

```cpp
Action action;
// operator() — это название метода.
// После него нужны ещё одни скобки.
action.operator()("Привет");

// Результат работы:
// Печать текста: 'Привет' 
```

Как и в других случаях, название операции можно убрать:

```cpp
Action action;
// "Вызываем" объект, как будто это функция.
// На самом деле вызываем operator().
// Так гораздо короче.
action("Привет"); 
```

Создав объект типа с определённым `operator()`, его можно поместить в `std::function`. Для этого можно создать переменную или временный объект:

```cpp
struct SayGoodMorning {
    void operator()(const std::string& name) {
        std::cout << "Доброе утро, " << name<< "!" << std::endl;
    }
};

int main(int argc, char *argv[]) {    
    // Вариант 1: 
    // Cоздать объект.
    SayGoodMorning say;
    
    // Запись в std::function.
    std::function<void(const std::string&)> action_say = say;
    
    //Вариант 2 — без создания экземпляра структуры.
    std::function<void(const std::string&)> action_say = SayGoodMorning{};
    // Вызов.
    action_say("Друг");
} 
```