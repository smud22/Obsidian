### Дружественные функции

У свободной функции есть особенность — она не имеет доступа к приватным членам класса.

```cpp
#include <iostream>

using namespace std::literals;

class Vector2I {
public:
    Vector2I(int x, int y) : x_{x}, y_{y} {};
  
private:
    int x_;
    int y_;
};

std::string operator+(const std::string &str, const Vector2I &value) {
    // Ошибка: нет доступа к приватным членам x_ и y_ класса Vector2I.
    return {str + "{"s + std::to_string(value.x_) + ", "s +
            std::to_string(value.y_) + "}"s};
}

std::string operator+(const Vector2I &value, const std::string &str) {
    // Ошибка: нет доступа к приватным членам x_ и y_ класса Vector2I.
    return {"{"s + std::to_string(value.x_) + ", "s + std::to_string(value.y_) +
            "}"s + str};
}

int main() {
    std::string a{"String value of Vector2I: "s};
    auto x_left = a + Vector2I{1, 1};
    std::cout << x_left << std::endl;
  
    std::string b{" - String value of Vector2I"s};
    auto x_right = Vector2I{1, 1} + b;
    std::cout << x_right << std::endl;
} 
```

Этот код не скомпилируется, поскольку `value.x_` и `value.y_` являются приватными полями класса `Vector2I`.

Для решения этой проблемы в языке предусмотрено ключевое слово `friend`. Оно позволяет сообщить, что некоторая функция имеет доступ к приватным членам класса. Функция декларируется через `friend` внутри класса, но считается не членом класса, а свободной функцией. `friend` часто используют для перегрузки операций:

```cpp
#include <iostream>

using namespace std::literals;

class Vector2I {
    int x_;
    int y_;

    // Хотя мы объявляем operator внутри класса, из-за 
    // friend это свободная функция, а не метод.
    friend std::string operator+(const std::string &str, const Vector2I &value);
    friend std::string operator+(const Vector2I &value, const std::string &str);

public:
    Vector2I(int x, int y) : x_{x}, y_{y} {};
};

std::string operator+(const std::string &str, const Vector2I &value) {
    // Эта функция — друг класса Vector2I, она 
    // может обращаться к приватным членам.
    return {str + "{"s + std::to_string(value.x_) + ", "s +
            std::to_string(value.y_) + "}"s};
}

std::string operator+(const Vector2I &value, const std::string &str) {
    // Эта функция также дружит с Vector2I.
    return {"{"s + std::to_string(value.x_) + ", "s + std::to_string(value.y_) +
            "}"s + str};
}

int main() {
    std::string a{"Строковое значение вектора: "s};
    auto x_left = a + Vector2I{1, 1};
    std::cout << x_left << std::endl;
  
    std::string b{" - строковое значение вектора."s};
    auto x_right = Vector2I{1, 1} + b;
    std::cout << x_right << std::endl;
} 
```

Через `friend` можно объявлять не только операции и функции, но и другие классы — они будут **дружественными классами**, изнутри которых можно получить доступ к приватным данным и методам другого класса.