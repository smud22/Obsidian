Объекты классов и структур тоже могут принимать участие в приведении типов. Для этого существует **конструктор преобразования** — особый вид конструктора, который создаёт объекты на основе переданных значений. Он может принимать один параметр (если принадлежит простому классу-обёртке) или несколько (если речь идёт о сложных классах или структурах).

Рассмотрим пример такого конструктора, позволяющего создать объект `Timer` из значения `int`.

```c
class Timer {
public:
    Timer() : seconds_(0) {}; // Обычный конструктор.
    Timer(int seconds) : seconds_(seconds) {}; // Конструктор преобразования.
    
    int GetTime() const { 
        return seconds_; 
    }
    ...
private:
    int seconds_;
};

int main() {
    // Конструктор преобразования можно вызвать явно.
    Timer timer_1(10);
    
    // Или неявно — компилятор поймёт, что это Timer(10).
    Timer timer_2 = 10;
} 
```

Запись `Timer timer_2 = 10;` позволяет выполнить неявное преобразование типов: из `int` в `Timer`. Это работает и в более сложных случаях: например, при передаче значения в функцию.

```c
void PrintTime(const Timer timer) {
    std::cout << "Оставшееся время: "s << timer.GetTime() 
              << " секунд"s << std::endl;
}

int main() {
    // В качестве параметра можно передать значение int —
    // оно автоматически преобразуется в Timer.
    PrintTime(15); 
} 
```

Возможны и обратные преобразования — из объекта класса в другой тип. Для этого необходимо создать перегрузку операции приведения типа.

```c
operator OtherType() const; 
```

Немного изменим наш пример, добавив переопределение для преобразования объекта `Timer` в значение типа `int`. В качестве результата он будет возвращать оставшееся время в секундах.

```c
class Timer {
public:
    Timer(int m, int s) : minutes_(m), seconds_(s) {};
    
    // Перегрузка приведения к int.
    operator int() const {
        return minutes_ * 60 + seconds_;
    }
private:
    int minutes_, seconds_;
}; 
```

Перегруженная операция не принимает параметров. К тому же для неё не указывается тип возвращаемого значения, поскольку подразумевается, что он соответствует её названию.

В итоге созданная перегрузка может участвовать как в явных, так и в неявных преобразованиях.

```c
Timer timer(10, 5);

int total_time_1 = static_cast<int>(timer); // Явное преобразование.
std::cout << total_time_1 << std::endl; // Напечатает количество секунд — 605.

int total_time_2 = timer; // Неявное преобразование.
std::cout << total_time_2 << std::endl;  
```

Аналогичным образом можно создавать перегрузки для других типов: например, для `bool`.

```c
// Перегрузка приведения к bool.
// Возвращает true, если остаётся время.
operator bool() const {
    return (minutes_ > 0) || (seconds_ > 0);
} 
```

Пример использования перегрузки.

```c
Timer timer{10, 5};   
if (timer) {
    std::cout << "Время ещё есть!"s << std::endl;
} 
```

Выражение `if (timer)` вызывает неявное приведение `timer` к `bool`, благодаря чему можно сразу проверить его значение.

Неявные преобразования не всегда полезны, и порой их нужно избегать — подробнее об этом в следующей части урока.