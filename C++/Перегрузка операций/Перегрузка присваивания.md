Один из плюсов операции присваивания в том, что при работе с простыми классами и структурами перегрузка ей не нужна. Например, можно использовать `=` с объектами типа `Point`, и всё будет отлично работать.

```c
struct Point {
    int x, y;
};

int main() {
    Point point_1{10, 20};
    Point point_2;

    point_2 = point_1;      // Используем перегрузку по умолчанию.
    std::cout << point_2.x; // 10.
} 
```

Это возможно, так как компилятор самостоятельно генерирует перегрузку присваивания. Она работает очень просто: копирует все нестатичные поля одного объекта в другой того же типа. Во многих случаях этого достаточно.

Явное использование присваивания по умолчанию можно задать с помощью слова `default`.

```c
struct Point {
    int x, y;
    
    Point& operator=(const Point& p2) = default;
};
 
```

Перегружать операцию присваивания вручную приходится в тех ситуациях, когда перенос значений между объектами требует более сложной логики и использовать реализацию по умолчанию нельзя. Часто это связано с выделением памяти и указателями. Например, если один элемент класса указывает на другой, его копия в новом объекте должна указывать на копию другого элемента, а не на оригинал.

Операцию `=` можно переопределить только в виде функции-члена класса или структуры. Таким образом, в качестве параметра она получает только правый операнд — значение, которое нужно присвоить.

Рассмотрим простой пример перегрузки: сделаем так, чтобы точке с тремя координатами (`Point3D`) можно было присваивать точки с двумя (`Point2D`).

```c
struct Point2D {
    int x, y;
};

struct Point3D {
    int x, y, z;
    
    Point3D& operator=(const Point2D& point_2d) {
        x = point_2d.x;
        y = point_2d.y;
        z = 0;
        return *this;
    }
};
    
int main() {
    Point2D point_2d{10, 20};
    Point3D point_3d{1, 1, 1};
    point_3d = point_2d;
    
    // Выведет: 10, 20, 0.
    std::cout << point_3d.x << ", "s << point_3d.y << ", "s << point_3d.z << std::endl;
} 
```

Операция присваивания выполняет два действия. Во-первых, меняет текущий объект. Во-вторых, она должна вернуть его, чтобы работало каскадирование.