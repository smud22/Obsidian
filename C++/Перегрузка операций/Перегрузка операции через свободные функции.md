Перегрузка операции с использованием метода класса требует использования экземпляра класса в качестве первого аргумента:

```c
// Экземпляр класса.
Vector2I c{3, 6};
// Запись через использование операции.
с - 1;
// Запись через явный вызов метода.
c.operator-(1); 
```

Иногда мы хотим использовать оператор для другого типа с использованием нашего класса в качестве второго операнда:

```c
// Экземпляр класса.
Vector2I c{3, 6};
// Запись через использование оператора.
1 - с;
// Запись через явный вызов функции.
operator-(1, с); 
```

Такой подход предполагает использование вызова перегруженной операции с помощью **свободной функции**.

Свободная функция — это функция, находящаяся вне какого-либо класса.

Свободные функции удобнее использовать для бинарных операций, поскольку они могут быть симметричными. Это значит, что если операция `x @ y` работает (здесь `@` обозначает любую операцию), то операция `y @ x` также должна работать для всех соответствующих типов.

```c
#include <iostream>

using namespace std::literals;

using Vector2I = std::pair<int, int>;

std::string operator+(const std::string &str, const Vector2I &vec) {
    return {str + "{"s + std::to_string(vec.first) + ", "s +
            std::to_string(vec.second) + "}"s};
}

std::string operator+(const Vector2I &vec, const std::string &str) {
    return {"{"s + std::to_string(vec.first) + ", "s +
            std::to_string(vec.second) + "}"s + str};
}

int main() {
    using namespace std;

    string a{"String value of Vector2I: "s};
    auto x_left = a + Vector2I{1, 1};
    cout << x_left << endl;

    string b{" - String value of Vector2I"s};
    auto x_right = Vector2I{1, 1} + b;
    cout << x_right << endl;
} 
```

Этот пример также показывает, что свободные функции позволяют улучшить класс, добавив бинарные операции, не внося новые функции-члены.

Если бы потребовалось использовать функцию-член для перегрузки операции сложения `string` и `Vector2I`, пришлось бы добавлять метод в класс `std::string`, что сделать невозможно.