Операции сравнения можно переопределять как внутри класса, так и в виде свободных функций. Как правило, второй способ предпочтительнее. Синтаксис перегрузки аналогичен тому, что вы изучили в прошлых уроках. В качестве примера перегрузим операцию `<` для класса `VectorInt`. По умолчанию векторы сравниваются по значениям элементов, но мы сделаем так, чтобы сравнивались размеры самих векторов.

```c
class VectorInt {
public: 
    VectorInt(std::vector<int> data): data_(data) {}
    
    int GetLength() const {
        return data_.size();
    }
    ...
    
private:
    std::vector<int> data_;
};

bool operator<(const VectorInt& lhs, const VectorInt& rhs) {
    return lhs.GetLength() < rhs.GetLength();
} 
```

Пример работы операции:

```c
VectorInt vec_1({100, 3});
VectorInt vec_2({1, 2, 3});

if (vec_1 < vec_2) {
    std::cout << "Первый вектор короче"s;
} 
```

Порой мы сталкиваемся с необходимостью сравнивать более сложные объекты, например структуры, имеющие несколько полей.

```c
struct Person {
    std::string first_name;  // Имя.
    std::string middle_name; // Среднее имя.
    std::string surname;     // Фамилия.
}; 
```

Нужно выполнять такое сравнение лексикографически, то есть сравнивать поля в определённом порядке: фамилия, имя, среднее имя. Чтобы реализовать эту логику, требуется довольно много кода.

```c
bool operator<(const Person& lhs, const Person& rhs) {
    // Если фамилии не равны, возвращаем результат их сравнения.
    if (lhs.surname != rhs.surname) {   
        return lhs.surname < rhs.surname;
    }
    // Если имена не равны, возвращаем результат их сравнения.
    if (lhs.first_name != rhs.first_name) { 
        return lhs.first_name < rhs.first_name; 
    }
    // Возвращаем результат сравнения средних имён. 
    return lhs.middle_name < rhs.middle_name;
} 
```

Этого можно избежать, преобразовав нужные поля структуры в единый объект с помощью функции `std::tie` из библиотеки `tuple`. Такие объекты компилятор может сравнивать сам.

```c
// Подключаем библиотеку, чтобы использовать tie.
#include <tuple> 

struct Person {
    ...
    auto ListToCompare() const {
        // Возвращает {фамилия, имя, среднее имя}.
        return std::tie(surname, first_name, middle_name); 
    }
};

bool operator<(const Person& lhs, const Person& rhs) {
    // Сравниваем объекты.
    return lhs.ListToCompare() < rhs.ListToCompare();
}

...

Person person_1("Richard"s, "Phillips"s, "Feynman"s);
Person person_2("John"s, "Archibald"s, "Wheeler"s);
if (person_1 < person_2) {
    std::cout << "Первое имя идёт раньше"s;
} 
```

Как видите, код операции стал гораздо компактнее. Теперь не нужно дублировать сложную логику, что упрощает работу и уменьшает вероятность ошибки.

![[Pasted image 20260116133901.png]]