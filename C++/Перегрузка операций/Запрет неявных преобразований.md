Несмотря на кажущееся удобство, неявное приведение типов делает программу более непредсказуемой и усложняет поиск ошибок.

Например, следующее использование `Timer` будет считаться корректным.

```c
class Timer {
public:
    Timer(int seconds) : seconds_(seconds) {}; // Конструктор преобразования.
    ...
};

int main() {
    Timer timer = -3.66363; // Этот код сработает.
} 
```

Компилятор выполняет приведение типов и не сообщает об ошибке, несмотря на то, что переданное значение времени очевидно неверное.

Эта же проблема может возникнуть с перегруженными операциями. Если для `Timer` определено приведение к `bool`, следующий код выполнится без ошибок, хотя в нём нет никакого смысла.

```c
Timer timer{0, 16};

// Неопределённое поведение. Возможный вывод — 4.
std::cout << (timer << 2) << std::endl; 
```

Чтобы избежать подобного поведения, используется ключевое слово `explicit`. Оно ставится рядом с конструктором или перегрузкой приведения, запрещая им участвовать в неявных преобразованиях.

```c
class Timer {
public:
    explicit Timer(int seconds) : seconds_(seconds) {};
    ...
};

int main() {
    Timer timer_1(60);        // Ок: конструктор вызывается явно.
    Timer timer_2 = -3.66363; // Ошибка: неявные преобразования запрещены.
    Timer timer_3 = 60;       // Всё ещё ошибка.
} 
```

Теперь создать объект `Timer` можно только с явным вызовом конструктора.

Похожим образом можно запретить автоматическое приведение к другим типам. В случае с `bool` ошибка компиляции сразу позволит найти некорректный код.

```c
class Timer {
public:
  explicit operator bool() const {
      return (minutes_ > 0) || (seconds_ > 0);
...
}

int main() {
    Timer timer{0, 16};
    std::cout << (timer << 2) << std::endl;   // Ошибка.
    
    bool has_time = static_cast<bool>(timer); // Явное приведение сработает.
} 
```

Слово `explicit` стоит использовать в тех случаях, когда неявные преобразования потенциально могут привести к неожиданным результатам или ошибкам — то есть практически всегда, за исключением ситуаций, когда автоматическое приведение логически оправдано.