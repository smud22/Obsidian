Вам уже известно, что при вводе объект потока получает значения из буфера и пытается записать их в переменные. Это возможно не всегда — порой возникают ошибки ввода. Они могут быть связаны с преобразованием типа или же с внутренней логикой программы — например, если при записи даты было введено отрицательное число. Благодаря перегрузкам мы можем реализовать дополнительную логику для проверки вводимых значений.

Следующий код записывает данные в структуру `Date`, только если все поля положительные.

```c
std::istream& operator>>(std::istream& is, Date& date) {
    int y, m, d;
    is >> y >> m >> d;
    
    if ( (y <= 0) || (m <= 0) || (d <= 0) ) {
        return is; // Если условие не выполнено, значения не записываются.
    }
    date.y_ = y;
    date.m_ = m;
    date.d_ = d;
    return is;
} 
```

При вводе некорректных значений эта функция не станет менять объект `date`. Это хорошо, но было бы лучше, если бы вместе с тем она сообщала нам, что что-то пошло не так. Для этого перегрузка должна возвращать не просто поток, а поток с флагом ошибки, который можно проверить после её вызова.

Чтобы перевести поток в состояние ошибки, можно воспользоваться методом `setstate` и флагом `std::ios::failbit`.

```c
if ( (y <= 0) || (m <= 0) || (d <= 0) ) {
    // Если условие не выполнено, не записываем значения 
    // и устанавливаем флаг ошибки.
    is.setstate(std::ios::failbit);
    return is; 
} 
```

Убедиться в корректности ввода можно знакомым вам способом — с помощью конструкции `if(!(std::cin))`.

```c
Date d;
if (!(std::cin >> d)) {
    std::cout << "Input error"s;
} 
```

Обратите внимание, что перегрузка ввода не предпринимает попыток «починить» поток самостоятельно. Её задача — вернуть результат операции, каким бы он ни был.

Ошибки ввода могут возникать и по другим причинам, например из-за несоответствия вводимых значений типам переменных (если вместо целого числа ввести дробное или строку). Аналогичным образом мы можем предусмотреть это в перегрузке.

```c
std::istream& operator>>(std::istream& is, Date& date) {
    int y, m, d;
    is >> y >> m >> d;

    if (is.fail()) { // Используем флаг fail для проверки потока.
        return is;   // Если ошибка, ничего не делаем.
    }
    date.y_ = y;
    date.m_ = m;
    date.d_ = d;
    return is;
} 
```

Здесь мы используем метод `fail`, который позволяет проверить успешность ввода так же, как `if (!(std::cin))`. Если что-то пошло не так, функция сразу возвращает поток. Он уже имеет флаг ошибки, поэтому устанавливать его вручную не нужно.

При перегрузке операции ввода стоит всегда добавлять обработку потенциальных ошибок. Это сделает код более надёжным и упростит его дальнейшее использование.