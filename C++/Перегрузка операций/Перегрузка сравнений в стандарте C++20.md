Хитрый подход с выражением всех операций через одну значительно упрощает разработку. Но с появлением стандарта C++20 хитрить больше не нужно: в этом стандарте появляется операция spaceship (`<=>`), избавляющая от необходимости перегружать операции вручную. Достаточно переопределить только её, и компилятор автоматически выведет все остальные (`<`, `<=`, `>`, `>=`).

```c
auto operator<=>(const VectorInt& lhs, const VectorInt& rhs) {
    return lhs.GetLength() <=> rhs.GetLength();
}
...

VectorInt v1({1, 2});
VectorInt v2({0, 0, 0});
std::cout << "v1 больше? - "s << (v1 > v2 ? "да"s : "нет"s) << std::endl; // Нет.
std::cout << "v2 больше? - "s << (v1 < v2 ? "да"s : "нет"s) << std::endl; // Да. 
```

В качестве результата перегрузка `<=>` должна возвращать запись `<левый операнд> <=> <правый операнд>`.

Операции равенства (`==` и `!=`) всё равно нужно определять отдельно, однако в C++20 достаточно написать только одну из них.

```c
auto operator==(const VectorInt& lhs, const VectorInt& rhs) {
    return lhs.GetLength() == rhs.GetLength();
}
...

// Операция == работает.
std::cout << "v1 и v2 равны? - "s 
          << (v1 == v2 ? "да"s : "нет"s) << std::endl; // Нет.
// И операция != тоже.
std::cout << "v1 и v2 не равны? - " 
          << (v1 != v2 ? "да" : "нет") << std::endl; // Да.
} 
```