Как и в случае с четырьмя арифметическими операциями, переопределяя инкременты и декременты, стоит создать перегрузки для всех четырёх вариантов. Ведь кто бы ни пользовался нашим кодом, с его стороны будет логичным ожидать, что, если работает одна из операций, можно использовать и другие.

Инкременты и декременты меняют непосредственно объекты классов или структур, поэтому их лучше реализовать как функции-члены.

Несмотря на внешнее сходство, префиксные и постфиксные формы операций реализуются по-разному, что обусловлено особенностями их работы. Для начала давайте рассмотрим префиксный вариант.

```c
class Timer {
public:
    Timer(int seconds): seconds_(seconds) { }
    int GetTime() const { return seconds_; }

    // Перегрузка префиксного инкремента.
    Timer& operator++() {
        seconds_ += 1; // Изменяем значение счётчика
        return *this; // и возвращаем ссылку на объект.
    }
    // Перегрузка префиксного декремента.
    Timer& operator--() {
        seconds_ -= 1;
        return *this;
    }
private:
    int seconds_;
};

int main() {
    Timer timer_1{10};
    Timer timer_2 = ++timer_1;
    std::cout << timer_1.GetTime() << std::endl; // Выведет 11.
    std::cout << timer_2.GetTime() << std::endl; // Выведет 11.
} 
```

Операции не принимают параметров, так как объявлены внутри класса. Первым шагом они уменьшают или увеличивают значение счётчика. Затем, используя `this`, они возвращают изменённую копию объекта.

Чтобы отличать объявления постфиксных операций от префиксных, для них указывается дополнительный параметр типа `int`. Как правило, он не используется внутри функции, и его имя принято опускать.

```c
class Timer {
    ...
    // Перегрузка постфиксного инкремента.
    Timer operator++(int) {
        Timer old_timer = *this; // Сохраняем старое значение.
        ++(*this); // Меняем значение.
        return old_timer;
    }
    // Перегрузка постфиксного декремента.
    Timer operator--(int) {
        Timer old_timer = *this;
        --(*this);
        return old_timer;
    }
    ...
};

int main() {
    Timer timer_1{10};
    Timer timer_2 = timer_1++;
    std::cout << timer_1.GetTime() << std::endl; // Выведет 11.
    std::cout << timer_2.GetTime() << std::endl; // Выведет 10.
} 
```

Эти операции должны возвращать исходную версию объекта, поэтому мы сохраняем её в переменную `old_timer` и только потом меняем значение. В этом примере мы используем ранее реализованные префиксные формы — это допустимо, если во всех операциях действует одна и та же логика.