Прежде чем перейти к алгоритму бинарного поиска, давайте вспомним, как устроен обычный алгоритм, с которым вы уже знакомы.

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s04_containers_and_algorithms/f321.jpg)

Предположим, что есть `std::vector` с целыми числами. Нужно понять, есть ли в этом векторе число `x`. Если нет никаких ограничений на расположение элементов, то можно лишь пройтись по всем числам и сравнить с искомым. Это называется **линейным поиском**.

```cpp
bool LinearSearch(const std::vector<int>& arr, const int x) {
    // Проходим по всему массиву.
    for (const int num : arr) {
        // Если находим элемент, равный x, возвращаем true.
        if (num == x) {
            return true;
        }
    }
    // Если в векторе нет такого элемента, возвращаем false.
    return false;
} 
```

Для упрощения функция `LinearSearch` возвращает `bool` — проверяет, есть нужный элемент или нет. Можно модифицировать эту функцию и возвращать итератор на найденный элемент, равный `x`. Также можно добавить в эту функцию поддержку произвольного компаратора: получатся алгоритмы `std::find` и `std::find_if`.

Если данных немного или поиск выполняется редко, алгоритм линейного поиска будет подходящим решением. В ситуации, когда важна эффективность поиска, необходимо использовать что-то другое (например, контейнер `std::set`).

Линейный поиск проходит по контейнеру. Если повезёт, он быстро найдёт искомый элемент. В худшем случае придётся проверить все элементы вектора.

