С написанием кода алгоритма помогут два понятия: **инвариант** и **полуинтервал**.

Понятие инварианта вам уже знакомо. Это некоторое утверждение, которое верно в определённый момент выполнения программы.

**Полуинтервал** `[a, b)` — это промежуток от `a` (включительно) до `b` (не включительно). Например, полуинтервал `[10, 15)` — это числа 10, 11, 12, 13, 14. Можно охарактеризовать эти числа следующим неравенством: где числа `x` такие, что `a <= x && x < b`. Слева нестрогое неравенство, справа — строгое. Полуинтервалы могут формироваться не только числами, но и, например, итераторами: элементы вектора — это полуинтервал от `begin()` до `end()`.

Для описания алгоритма удобно пользоваться полуинтервалами индексов вида `[a, b)`.

Отдельно выделяется полуинтервал, концы которого совпадают. Пример: `[10, 10)`. Считается, что он пуст — не содержит ни одного числа.

---

Давайте представим, что алгоритм бинарного поиска ищет в векторе `arr` элемент `x`. Нам нужен индекс элемента, который может быть числом от 0 до `arr.size() - 1`. Иными словами, индекс находится в полуинтервале `[0, arr.size())`.

Обозначим полуинтервал `[a, b)`. Изначально `a = 0`, `b = arr.size()`. На каждом шаге алгоритма будем сокращать интервал поиска, меняя либо `a`, либо `b`. Для этого возьмём середину между `a` и `b`. Программно её можно вычислить так: `mid = (a + b) / 2`. Как вы знаете, деление целых чисел всегда даёт целое число. Пример: для полуинтервала `[4, 9)` серединой будет 6 = (4 + 9) / 2.

`mid` разделяет полуинтервал на две половины: `[a, mid)`, `[mid, b)`. Чтобы понять, в какой находится элемент `x`, сравним его с `arr[mid]`. В зависимости от результата сравнения поменяем либо `a`, либо `b` и перейдём к следующему шагу алгоритма.

При таком подходе будет выполняться инвариант: если `x` есть в векторе, то он находится на полуинтервале `[a, b)`.

Когда остался только один вариант, необходимо убедиться, тот ли это индекс, который мы искали, и возвратить ответ. Получается такой алгоритм:

```cpp
// Возвратим индекс элемента в векторе или nullopt, если не нашли его.
std::optional<size_t> BinarySearch(const std::vector<int>& arr, const int x) {
    size_t a = 0;
    size_t b = arr.size();
    
    // Пока полуинтервал содержит два числа или больше.
    while (b - a >= 2) {
        // Инвариант: если x есть в векторе arr,
        // то он лежит между arr[a] и arr[b - 1].
    
        // Считаем середину полуинтервала.
        const size_t mid = (a + b) / 2;
        
        // Иначе — нужно понять, в какой половине может быть x.
        if (x < arr[mid]) {
            // x в левой половине. Меняем b. 
            // Получим полуинтервал [a, mid).
            b = mid; 
        } else {
            // x в правой половине. Меняем a. 
            // Получим полуинтервал [mid, b).
            a = mid;
        }
    }
    
    // На полуинтервале осталось одно число.
    // Проверим: то ли это, что мы искали.
    if (a == b || arr[a] != x) {
        // Не нашли :(
        return std::nullopt;
    }
    
    return arr[a];
} 
```

Важная идея алгоритма бинарного поиска — использование информации о данных для максимально эффективной работы. В разобранном нами случае для быстрого уменьшения полуинтервала поиска используются отсортированные данные. Иначе алгоритм может работать неправильно и возвращать результат, которому нельзя доверять.

На самом деле алгоритм бинарного поиска не требует, чтобы данные были полностью отсортированы. В процессе работы элементы вектора сравниваются не друг с другом, а только с искомым элементом `x`. Достаточно, чтобы они были отсортированы относительно элемента `x`. То есть сначала в векторе идут элементы меньше `x`, потом равные `x`, а потом те, что больше `x`. Такие данные называются разделёнными относительно `x`. И для разделённого относительно `x` вектора бинарный поиск элемента `x` будет работать верно.