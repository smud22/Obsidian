Линейный поиск делает проверки, проходя по вектору. С каждой проверкой он исключает из рассмотрения только один элемент, пока не найдёт нужный. А что, если данные в векторе отсортированы как главы в книге? В примере с поиском главы 4 вы увидели, что для упорядоченных данных можно исключать существенное число элементов — страницы, идущие после страницы 100, посмотрев только на один — страницу 100.

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s04_containers_and_algorithms/f320.jpg)

Рассмотрим элемент отсортированного вектора `arr` с индексом `i`. Выполним проверку: `x < arr[i]`.

```
std::vector<int> arr;

if (x < arr[i]) {
    // Ищем x среди индексов 0, ..., i-1.
} else {
    // Ищем x среди индексов i, ..., arr.size() - 1.
} 
```

У проверки два исхода:

1. `true` — `x` меньше `arr[i]`. А значит, он меньше всех элементов с большими индексами. Можем исключить из рассмотрения все элементы с индексами `i`, `i + 1`, … до конца вектора. Теперь `x` нужно искать среди элементов с индексами от `0` до `i - 1`.
2. `false` — `x` больше `arr[i]` либо равен `arr[i]`. Исключим те индексы, которые рассматривали в первом случае.

**Принцип алгоритма бинарного поиска** — отсекать максимальное количество элементов за каждую проверку. Но какой элемент проверять в первую очередь? Хорошая идея — проверять середину текущего набора элементов. Тогда в любом случае будет отсечена примерно половина.

Давайте посмотрим, как это будет работать для вектора `arr` из 6 элементов с индексами от 0 до 5. Середина для вектора из 6 элементов — это элемент с индексом 2, он делит массив на две группы: 0, 1 и 2, 3, 4, 5. Выполним проверку `x < arr[2]`, чтобы узнать, в какой группе находится нужный элемент.

На первом шаге мы исключили 2 индекса и оставили другие 4. Предположим, что остались 2, 3, 4, 5. Поделим их ещё раз пополам. Выберем элемент 3, который поделит элементы на две группы: первая будет состоять всего из одного элемента с индексом 2, вторая из трёх — с индексами 3, 4, 5. Проверка позволит понять, в какой из этих групп будет искомый элемент.

Если победила первая группа (та, что с двойкой), то ответ найден. Если нет, будет нужна ещё одна проверка. Итак, наш поиск сделал три шага. Это в два раза лучше, чем если бы мы использовали алгоритм линейного поиска. Но такой выигрыш — далеко не предел.

Обратите внимание: чем больше количество элементов, тем очевиднее эффективность бинарного поиска в сравнении с линейным.

Например, возьмём типичный файл с подкастом в контейнере .mp4, который хранит аудиоданные кусочками (семплами). Для девяностоминутного файла их может быть порядка 250 тысяч. Для перемотки к нужному моменту времени нужно найти соответствующий семпл. Бинарному поиску потребуется около 18 шагов для поиска в 250 тысячах семплов.