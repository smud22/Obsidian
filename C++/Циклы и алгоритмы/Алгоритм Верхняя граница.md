`std::lower_bound` позволяет найти первый элемент, больший искомого либо равный ему. Если нужно найти строго больший элемент, нужно использовать алгоритм **верхняя граница** (англ. upper bound). В стандартной библиотеке есть соответствующий алгоритм — `std::upper_bound`. Работает он так же, как поиск нижней границы, только вместо сравнения `<` использует `<=`. Первый элемент, не удовлетворяющий этому условию, будет строго больше искомого.

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s04_containers_and_algorithms/v12.jpg)

Вот примеры применения `std::upper_bound` к тому же массиву `arr`. При поиске отсутствующей `2` результат будет такой же, как и при вызове `std::lower_bound`:

```cpp
std::vector<int> arr = {0, 0, 1, 3, 3, 5, 7};

// Итератор на первый элемент больше 2.
const auto it1 = std::upper_bound(arr.begin(), arr.end(), 2);
// it1 указывает на первую тройку в массиве arr с индексом 3.
// it1 ------------↴
// arr = {0, 0, 1, 3, 3, 5, 7} 
```

Но при поиске существующего в массиве числа `upper_bound` вернёт другой результат. Этот алгоритм ищет строго большее число:

```cpp
// Итератор на первый элемент больше 5.
const auto it2 = std::upper_bound(arr.begin(), arr.end(), 5);
// В массиве есть 5, но it2 указывает на 7.
// it2 ---------------------↴
// arr = {0, 0, 1, 3, 3, 5, 7} 
```