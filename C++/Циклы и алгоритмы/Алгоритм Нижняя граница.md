Алгоритм **нижняя граница** (англ. lower bound) ищет первый элемент, не удовлетворяющий неравенству `<` (другими словами — первый элемент в массиве, больший искомого либо равный ему). Реализация поиска нижней границы похожа на реализацию бинарного поиска из прошлого урока.

В C++ есть соответствующая функция `std::lower_bound`. На вход она принимает диапазон итераторов и возвращает итератор на искомый элемент. `std::lower_bound` находит первый элемент, который больше искомого или равен ему.

Так как числа 2 нет в векторе, то результат поиска — первая тройка:

```cpp
std::vector<int> arr = {0, 0, 1, 3, 3, 5, 7};

// Итератор на первый элемент не меньше 2.
const auto it1 = std::lower_bound(arr.begin(), arr.end(), 2);
// it1 указывает на 3 с индексом 3.
// it1 ------------↴
// arr = {0, 0, 1, 3, 3, 5, 7} 
```

Если в массиве есть искомый элемент, то будет возвращён итератор на него:

```cpp
// Итератор на первый элемент не меньше 5.
const auto it2 = std::lower_bound(arr.begin(), arr.end(), 5);
// В массиве есть 5. it2 указывает на 5 с индексом 5.
// it2 ------------------↴
// arr = {0, 0, 1, 3, 3, 5, 7} 
```

Попытка найти в `arr` первый элемент не меньше 9 увенчается `arr.end()`, потому что такого элемента в массиве нет. Все элементы заданного диапазона меньше 9.

```cpp
// Итератор на первый элемент не меньше 9.
const auto it3 = std::lower_bound(arr.begin(), arr.end(), 9);
// В arr нет элемента не меньше 9, поэтому it3 указывает на arr.end().
// it3 -----------------------↴
// arr = {0, 0, 1, 3, 3, 5, 7} 
```

Алгоритм `std::lower_bound` можно использовать с произвольным компаратором (функцией сравнения). Элемент сравнения передаётся третьим параметром, компаратор — четвёртым. Функция-компаратор принимает объект перебора и элемент сравнения. Его тип может быть любым.

```cpp
struct Person {
    std::string name;
    int age;
};

// Вектор, отсортированный по возрасту.
std::vector<Person> persons = ...;

// Вызов lower_bound с произвольным компаратором.
// В данном случае сравнение возраста всегда будет происходить с числом 5.
const auto it = std::lower_bound(
    persons.begin(), persons.end(), 5,
    [](const Person& person, const int age) {
        return person.age < age;
    });

// it — это итератор на первого человека не младше 5 лет.
// Теперь можно, например, узнать, сколько в persons людей младше 5.
std::cout << std::distance(persons.begin(), it) << " людей младше 5 лет"s << std::endl; 
```

В этом примере в массиве `persons` хранятся структуры `Person`, отсортированные по полю `age`. В таком случае можно использовать `std::lower_bound` для поиска по возрасту. В данном случае используется произвольный компаратор, который сравнивает возраст элементов массива `person.age` с искомым возрастом `age`, равным `5`.