Давайте внимательнее рассмотрим последний вариант последнего вопроса. Как вы уже знаете, в цикле `for` можно произвольно изменять счётчик, в том числе и уменьшать. Что может привести к неожиданным последствиям в некоторых случаях. Напишем цикл, который выведет числа от девяти до нуля в порядке убывания:

```cpp
// Если запустите такой цикл, получите ровно то, что и хотели.
for (int i = 9; i >= 0; --i) {
    std::cout << i << std::endl;
} 
```

Когда значение счётчика `i` доходит до нуля, мы проверяем условие `i >= 0`, которое истинно. Далее мы попадаем в тело цикла, выводим в поток ноль и уменьшаем счётчик. Его значение становится -1, проверка условия выполнения заканчивается неудачей, и цикл завершается. Всё очевидно, не так ли?

Но давайте изменим тип на беззнаковый и попробуем ещё раз.

```cpp
// Если запустите такой цикл, получите неожиданный результат.
for (size_t i = 9; i >= 0; --i) {
    std::cout << i << std::endl;
} 
```

В результате программа начнёт выводить что-то совсем неблизкое по значениям к числам от нуля до девяти. Более того, она зависнет!

Тип `size_t` — беззнаковый, поэтому выражение `i >= 0` в этом случае просто не может быть ложно. По-прежнему, когда значение счётчика `i` станет равно нулю, мы попадаем в тело цикла, выводим ноль в поток. Затем программа пытается уменьшить значение счётчика. Но теперь у нас беззнаковый тип, который не поддерживает отрицательных значений. В таком типе -1 превращается в самое большое положительное число, поддерживаемое данным типом. И так как значение счётчика снова больше нуля, условие выполнения истинно, цикл продолжается и будет продолжаться бесконечно.

Чтобы избежать переполнения, используют приём с постфиксным декрементом и смещённой стартовой границей счётчика.

```cpp
// Здесь используется некрасивый трюк:
// изменение счётчика происходит в условии цикла.
for (size_t i = 10; i-- > 0; ) {
    std::cout << i << std::endl;
} 
```

Но можно применить логику и обойтись без таких трюков:

```cpp
// Обычный цикл от 0 до 9
for (size_t i = 0; i <= 9; ++i) {
    // А тут используем 9 - i вместо i. Получим нужный
    // обратный отсчёт.
    std::cout << 9 - i << std::endl;
} 
```

Как правило, используется префиксный инкремент и декремент: `++i` и `--i`. Считается, что он более эффективный, потому что ему не нужно создавать копию значения. В современных компиляторах разницы, скорее всего, не будет — в них достаточно хороший оптимизатор, который сможет исключить все ненужные действия. Но рекомендуется всё равно писать `++i`, чтобы показать, что вы думаете об эффективности.