### Перегрузка доступа по индексу

Операция индекса (или взятия по индексу) — это знакомые вам квадратные скобки `[]`, которые позволяют получить элемент последовательности по его порядковому номеру (в C++, как и во многих языках программирования, нумерация начинается с 0).

По умолчанию доступ по индексу применим к встроенным типам, представляющим последовательность (например, векторы и строки). Мы можем перегрузить его, чтобы применять к классам и доставать из них нужные элементы. В этом случае класс можно рассматривать как вектор (или контейнер), хранящий упорядоченные данные.

В качестве примера посмотрим на класс `VectorUnion`, который содержит два вектора (`v1_` и `v2_`) и позволяет работать с ними как с одним (`v1_` + `v2_`).

```c
class VectorUnion { 
public:
    VectorUnion(const std::vector<int>& v1, 
                const std::vector<int>& v2): 
                v1_(v1), v2_(v2) { }
    
    int operator[](std::size_t index) const {
        if (index < v1_.size()) { 
            return v1_[index]; 
        } else { 
            return v2_[index - v1_.size()];
        }
    }
private:
    std::vector<int> v1_, v2_; // Данные хранятся в двух векторах.
};

int main() {
    VectorUnion vec{{1, 2, 3}, {40, 50, 60}};
    
    // Можем работать с vec как с одним
    // большим вектором: {1, 2, 3, 40, 50, 60}.
    // Индексы:           0  1  2   3   4   5.
    std::cout << vec[5]; // Напечатает 60.
} 
```

Поскольку операция `[]` работает непосредственно с объектами класса, она объявляется только как функция-член. В качестве параметра она принимает индекс — идентификатор элемента, который нужно вернуть. При этом индекс может быть любого типа: как числом, так и строкой.

В приведённом примере перегрузка объявлена со словом `const`. Это значит, что операция допускает только чтение элементов, и мы не можем их менять. Если нужно обеспечить и чтение, и запись, принято определять два варианта перегрузки: константный и неконстантный.

Неконстантный метод должен возвращать ссылку, чтобы обеспечить прямой доступ к элементу, благодаря чему его можно редактировать.

Константный метод может возвращать либо копию объекта (как выше в примере с `int`), либо ссылку на него. Второй способ подходит для сложных объектов, так как избавляет от лишнего копирования.

```c
class VectorUnion { 
    int& operator[](std::size_t index) { ... } // Перегрузка для записи.
    const int& operator[](std::size_t index) const { ... } // И для чтения.
}; 
```

При перегрузке индекса мы берём на себя ответственность за корректную работу операции. Поэтому важно учитывать случаи, когда ей может быть передан некорректный параметр (например, индекс, выходящий за пределы последовательности). Обработать невалидный индекс можно так.

```c
int& operator[](std::size_t index) {
    if ((index < 0) || (index >= (v1_.size() + v2_.size()))) {
        std::abort(); // Если индекс неверный, завершаем программу.
    }
    if (index < v1_.size()) { 
        return v1_[index]; 
    } else { 
        return v2_[index - v1_.size()];
    }
} 
```

Если в качестве индексов используются строки, мы получаем контейнер, в котором информация хранится в виде пар **«строковый индекс — значение»** или **«ключ — значение»**. Такая структура данных называется **словарём**. Словари достаточно часто используются в программировании, в том числе в C++. Подробнее о них — в следующем спринте.

До этого мы рассматривали случаи, когда операция `[]` принимала один индекс. Начиная со стандарта C++23, ей можно передавать сразу несколько индексов, записывая их через запятую. Это свойство удобно использовать при создании матриц — объектов, хранящих данные в виде таблицы.

```c
class Matrix{
public: 
    Matrix(std::vector<int> data, int stride): 
           data_(data), stride_(stride) {}
    
    // Перегрузка с двумя индексами.
    int& operator[](int col, int row) {
        return data_[col + stride_ * row];
    }
private:
    std::vector<int> data_; // Элементы хранятся в одном векторе.
    int stride_; // Ширина таблицы (количество столбцов).
}; 
```

Этот пример также хорошо иллюстрирует принятый подход к записи таблиц в память компьютера. Вместо того чтобы хранить столбцы и строки, таблицу «разворачивают» в единую последовательность элементов и сохраняют исходное значение ширины (`stride_`). Позже его используют, чтобы найти нужный элемент по номерам строки и столбца: `data_[col + stride_ * row]`.

Далее созданную матрицу можно использовать для записи, чтения и изменения элементов.

```c
// Матрица (таблица) чисел:
// 11 12 13 14
// 21 22 23 24
// 31 32 33 34
Matrix matrix({11, 12, 13, 14, 21, 22, 23, 24, 31, 32, 33, 34}, 4);

// Берём второй элемент в первой строке (23).
std::cout << matrix[2, 1] << std::endl;

// Так как возвращается ссылка, можем
// менять элемент матрицы:
matrix[0, 0] = 100; 
```

Перед вами класс `Vector` с перегрузкой взятия по индексу.

```c
class Vector { 
public:
    Vector(const std::vector<int>& v): v_(v) { }
    
    int& operator[](std::size_t index) {
        if ((index <= 0) || (index > v_.size())) {
            std::abort();
        }
        return v_[index - 1];
    }
private:
    std::vector<int> v_;
}; 
```

### Перегрузка операции вызова функции

C++ позволяет перегружать и более необычные операции. Например, круглые скобки `()`, вызывающие объект как функцию.

```c
struct Linear {
    double a, b;
    
    // Перегрузка операции.
    double operator()(double x) const {
        return a * x + b;
    }
};
 
int main() {
    Linear func{2, 1};    // Представляет функцию 2x + 1.

    double f_0 = func(0); // Посчитает: 2 * 0 + 1 = 1.
    double f_5 = func(5); // Посчитает: 2 * 5 + 1 = 11.
} 
```

В этом примере перегрузка позволяет использовать объект `func` аналогично функциям. Подобные объекты в C++ называются **функторами** (хотя в других языках этот термин имеет другое значение). Мы расскажем о функторах более подробно в теме про лямбда-функции.

### Дополнительные возможности: пользовательские литералы

Литерал — это константа, записанная в коде. Литералы бывают:

- целочисленные (например, -42, 55UL, 0x1f);
- с плавающей точкой (например, 3.14, -1.e-15);
- строковые (например, `"Hello, Oleg"`);
- символьные (например, `'a'`, `'\0'`).

Ещё есть **пользовательские** литералы. В этом случае к стандартному литералу добавляется суффикс. Например, так можно получить строку типа `std::string`: `"Hello, Oleg"s` (суффикс `s`). А так — 15 миллисекунд: `15ms` (суффикс `ms`). Для использования этих литералов нужно написать `using namespace std::literals`.

Можно создавать собственные пользовательские литералы, определяя новые суффиксы. Но есть одно требование — они должны начинаться с подчёркивания `_`.

```c
// Литерал для задания килобайтов.
unsigned long long operator"" _Kb(unsigned long long x) { return x * 1024; }

// Литерал для задания мегабайтов.
unsigned long long operator"" _Mb(unsigned long long x) { return x * 1024 * 1024; }

// Литерал, обращающий строку.
std::string operator"" _Rev(const char* ptr, size_t size) {
    std::string str(ptr, size);
    std::reverse(str.begin(), str.end());
    return str;
}

int main() {
    // 10 килобайт.
    std::cout << 10_Kb << std::endl; // 10 * 1024 = 10240.

    // Сколько килобайт в 500 мегабайтах:
    std::cout << (500_Mb / 1_Kb) << std::endl; // 512000.
    
    std::cout << "telefon"_Rev << std::endl; // nofelet.
} 
```

C++ позволяет создавать пользовательские литералы для целых значений, значений с плавающей точкой и строк. Например, вы можете создать литерал для удобного получения `QString`. Но в реальных программах эта возможность используется нечасто, поэтому не будем на ней останавливаться.

В этом уроке мы рассказали о нескольких видах операций, которые можно перегружать для собственных целей. Доступ по индексу позволяет использовать класс в качестве контейнера, а вызов функции — в качестве функционального объекта.