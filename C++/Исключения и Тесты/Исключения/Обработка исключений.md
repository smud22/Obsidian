Мы уже упоминали, что исключения можно перехватывать и обрабатывать в коде, благодаря чему проблема решается, и программа продолжает работу. В противном случае она либо завершается, либо демонстрирует неопределённое поведение.

Для обработки исключений в C++ существует конструкция `try-catch`. В блок `try` помещается код, который потенциально может выбросить исключение, а в блоке `catch` — действия, которые нужно выполнить в этом случае.

```cpp
try {
    std::string str = "Geronimo";
    str.at(8) = '!'; // Попытаемся изменить символ за пределами строки.
} catch (const std::exception& e) {
    std::cerr << "Ошибка: " << e.what() << std::endl;
}
// Вывод:
// Ошибка: basic_string::at: __n (which is 8) >= this->size() (which is 8) 
```

В этом примере в блоке `try` происходит ошибка, вызывающая исключение `std::out_of_range`, которое затем перехватывается и обрабатывается в блоке `catch`. Метод `what()` выводит стандартное сообщение о полученной ошибке.

Запись `catch (const std::exception& e)` значит, что `catch` отреагирует на любое исключение, в том числе `std::out_of_range`.

Тип `std::exception` является общим для исключений и содержит более специфичные типы. В их числе, например:

- `std::runtime_error` — для ошибок во время выполнения программы. К этому типу относятся такие исключения, как `std::range_error` и `std::overflow_error`.
- `std::logic_error` — для ошибок, которые можно найти до выполнения, например `std::invalid_argument` или `std::out_of_range`.
- `std::bad_cast` — ошибки, возникающие из-за неудачного динамического приведения типов.

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s05_oop/2024-11-26_13-03-28.png)

Такая структура позволяет обрабатывать ошибки на разном уровне детализации: от самых общих, когда неважно, что именно пошло не так, до очень специфичных, когда нужно точно знать тип исключения. Например, следующий код обработает любое исключение типа `std::runtime_error`, будь то `std::range_error`, `std::overflow_error` или другие.

```cpp
catch (const std::runtime_error& e) { ... } 
```

А в этом примере обработчик отреагирует только на исключение `std::range_error`.

```cpp
catch (const std::range_error& e) { ... } 
```

При наличии нескольких подходящих обработчиков выбирается самый специфичный, то есть тот, который находится ниже в иерархии исключений. Поэтому в коде важно располагать обработчики от более специфичных к более общим.

Как вызывается подходящий `catch`?

При возникновении исключения программа начинает искать ближайший подходящий блок `catch`. Если он находится в той же функции, то он вызывается, чтобы обработать проблему. Код выполняется дальше.

Если функция, в которой было вызвано исключение, не имеет подходящего обработчика, она завершается, а исключение передаётся функции, которая её вызвала, и ищет `catch` в ней. Это может продолжаться вплоть до функции `main`. Если обработчик не найдётся на всём стеке вызовов, код завершится с ошибкой.

```cpp
void InnerFunction() {
    // Код, который генерирует исключение типа А.
}

void MiddleFunction() {
    try {
        InnerFunction();
    } catch (<исключение типа B>) { ... } // Не подходит.
    // Функция прервётся, а исключение А перейдёт к OuterFunction.
    ...
}

void OuterFunction() {
    try {
        MiddleFunction();
    } catch (<исключение типа А>) { 
            // Здесь обработается ошибка из InnerFunction.
    }
} 
```