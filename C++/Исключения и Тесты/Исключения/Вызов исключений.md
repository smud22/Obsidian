Кроме стандартных случаев генерации исключений, в C++ можно вызывать исключения самостоятельно. Это полезно в тех ситуациях, когда ваши классы или функции сталкиваются с проблемой, которая нарушает их работу.

В примере с классом `Rational` такой проблемой была попытка создать дробь с нулевым знаменателем. Ранее в этом случае вы использовали команду `std::abort`, чтобы остановить программу. Вместо этого можно сгенерировать исключение, которое класс будет «выбрасывать» наружу и которое можно обработать. Это делается с помощью команды `throw`.

```cpp
#include <iostream>
#include <numeric>
#include <stdexcept> // Для std::runtime_error.

class Rational {
public:
    Rational(int numerator, int denominator)
    : numerator_(numerator)
    , denominator_(denominator) {
        if (denominator_ == 0) {
            // Вместо std::abort() генерируем исключение.
            throw std::runtime_error("Деление на ноль!");
    }
    if (denominator_ < 0) {
        numerator_ = -numerator_;
        denominator_ = -denominator_;
    }
    ...
  }    
private:
    int numerator_ = 0;
    int denominator_ = 1;
};

int main() {
    try {
        auto r = Rational(5, 0);
        std::cout << r << std::endl;
    } catch (const std::runtime_error &e) {
        std::cerr << "Ошибка: " << e.what() << std::endl;
    }
    std::cout << "Программа завершается без прерываний." << std::endl;
}
// Вывод:
// Ошибка: Деление на ноль!
// Программа завершается без прерываний. 
```

Запись `throw std::runtime_error("Деление на ноль!")` выбрасывает стандартное исключение типа `std::runtime_error`, а в скобках описывается причина ошибки.

При необходимости можно создавать исключения собственного типа. Например, для обработки ошибок, связанных с парсингом строк.

```cpp
class ParseException {
public: 
    ParseException(std::string message): message_ {message} {}

    std::string GetMessage() const { 
        return message_; 
    }
private:
    std::string message_;
}; 
```

Класс `ParseException` содержит всего одну переменную — для текста ошибки.

Его можно использовать вместе с `throw` и `catch`.

```cpp
...
throw ParseException("Неверный формат строки.");
...

try { ... } 
catch (const ParseException& e) {
    std::cerr << "Ошибка: " << e.GetMessage() << std::endl;
} 
```

Такой подход позволяет использовать исключения для нестандартных задач. В качестве примера рассмотрим функцию `VectorFromString`, которая принимает строку формата `"слово1,слово2,слово3"` и преобразовывает её в вектор `["слово1", "слово2", "слово3"]`.

```cpp
#include <iostream>
#include <sstream>
#include <vector>

...
std::vector<std::string> VectorFromString(const std::string& input) {
    std::vector<std::string> result;
    std::stringstream ss(input);
    std::string word;
    
    if (input.empty()) {
        throw ParseException("Пустая строка.");
    }
    if ( // Убедимся, что в строке нет лишних символов и пробелов.
        input.front() == ',' || 
        input.back() == ',' || 
        input.find(' ') != std::string::npos
        ) {
            throw ParseException("Неверный формат строки.");
    }
    while (std::getline(ss, word, ',')) {
        if (word.empty()) {
            throw ParseException("Неверный формат строки.");
        }
        result.push_back(word);
    }
    return result;
} 
```

При любой ошибке парсинга функция выбрасывает `ParseException` с соответствующим сообщением. Исключение попадает в нужный обработчик и не пересекается с другими.

```cpp
try {
    auto words = VectorFromString("");
} catch (const ParseException& e) { 
    std::cerr << "Ошибка: " << e.GetMessage() << std::endl;
}
try {
    auto words = VectorFromString("мяу ,, мяу");
} catch (const ParseException& e) {
    std::cerr << "Ошибка: " << e.GetMessage() << std::endl;
}
try {
    auto words = VectorFromString("мяу,мяу");
    std::cout << "Функция отработала без ошибок.";
} catch (const ParseException& e) {
    std::cerr << "Ошибка: " << e.GetMessage() << std::endl;
}
// Вывод:    
// Ошибка: Пустая строка.    
// Ошибка: Неверный формат строки.
// Функция отработала без ошибок. 
```

В этом уроке рассмотрен простой способ создания своих исключений. В более сложных ситуациях вы можете сделать исключение собственного типа частным случаем другого исключения, например `std::runtime_error`. Для этого используют наследование, которое вы изучите далее.