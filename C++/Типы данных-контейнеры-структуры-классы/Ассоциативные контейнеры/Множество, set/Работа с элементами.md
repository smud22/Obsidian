Одна из самых частых операций с `std::set` — это проверка наличия элемента. Её можно выполнить с помощью метода `contains`, который возвращает логическое значение.

```cpp
std::set words = {
    "hello"s, "world"s, "hello"s
};

auto word = "hello"s;
if (words.contains(word)) {
    std::cout << "Слово уже есть"s << std::endl;
} 
```

Второй способ — метод `find`, возвращающий итератор, указывающий либо на найденное слово, либо на конец контейнера, если поиск оказался неудачным.

```cpp
auto word = "hello"s;
auto iter = words.find(word);

if (iter != words.end()) {
    std::cout << "Слово уже есть"s << std::endl;
} 
```

Ещё одна полезная операция — перебор элементов множества. Как и в случае с `std::map`, это можно сделать как с помощью итераторов, так и обращаясь к значениям напрямую через ссылку.

```cpp
// Перебор через итераторы.
for (auto iter = words.begin(); iter!= words.end(); ++iter) {
    std::cout << *iter << std::endl;
}

// Перебор через ссылку.
for (const auto& word : words) {
    std::cout << word << std::endl;
}
// Вывод:
// hello
// world 
```

В обоих случаях значение (итератор или ссылка), которое участвует в цикле, является константным. Через него нельзя менять элементы множества.

```cpp
for (auto iter = words.begin(); iter!= words.end(); ++iter) {
    *iter = "another"s; // Ошибка!
} 
```

---

Изменение значений — сложная операция, которая потребовала бы перестроения всего «дерева» (структуры данных). Вместо этого можно удалить ненужный элемент и добавить в множество новый. Удаление выполняется с помощью метода `erase`, который может работать и со значениями, и с итераторами.

```cpp
// Удаление по значению.
words.erase("hello"s);

// Удаление по итератору.
words.erase(words.find("hello"s)); 
```

Если указанный элемент нашёлся в контейнере и был успешно удалён, `erase` возвращает `true`.

```cpp
auto is_erased = words.erase("hello"s);
    
if (is_erased) {
    std::cout << "Элемент был удалён"s << std::endl;
} 
```