Как и большинство структур данных в библиотеке STL, `std::set` является шаблоном, поэтому при создании необходимо указать тип его элементов.

```cpp
std::set<int> years; 
```

Если множество инициализируется сразу, шаблонный аргумент можно опустить.

```cpp
std::set years = {1917, 1984, 1917};

// years = {1917, 1984}. 
```

В множество будут записаны только уникальные значения из списка инициализации, отсортированные по возрастанию.

Чтобы узнать, есть ли элементы в множестве и сколько их, можно использовать знакомые вам методы `empty` и `size`.

```cpp
std::set words = {
    "world"s, "hello"s, "hello"s
};
    
if (!words.empty()) {
    std::cout << "Множество не пустое. Количество элементов = "s 
              << words.size() << std::endl;
}
// Множество не пустое. Количество элементов = 2. 
```

Для добавления новых элементов в `std::set` есть метод `insert`, который работает аналогично методу `insert` для `std::map`. Он позволяет вставлять значения, которые будут сохранены только в том случае, если их ещё не было в множестве.

```cpp
std::set years = {1917, 1984};

years.insert(1561); // Ок: это новый элемент.
years.insert(1984); // Этот элемент не будет добавлен.

// years = {1561, 1917, 1984}. 
```

Результат операции можно узнать по значениям, которые возвращает `insert`: итератору, указывающему на место нового элемента, и флагу, равному `true`, если элемент успешно добавлен.

```cpp
auto [iterator, is_inserted] = years.insert(1984);
    
if (is_inserted) {
    std::cout << "Добавлен год: "s << *iterator;
} else {
    std::cout << "Этот год уже записан!"s;
} 
```