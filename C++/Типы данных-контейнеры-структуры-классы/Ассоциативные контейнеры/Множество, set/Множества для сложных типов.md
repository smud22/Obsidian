Подобно другим контейнерам, `std::set` может хранить простые и сложные объекты. Например, мы можем создать множество из векторов.

```cpp
std::set<std::vector<int>> set_of_vectors;
    
std::vector<int> vec_1 = {1, 2, 3};
std::vector<int> vec_2 = {4, 5, 6};
std::vector<int> vec_3 = {1, 2, 3};

set_of_vectors.insert(vec_1);
set_of_vectors.insert(vec_2);
set_of_vectors.insert(vec_3);

// set_of_vectors = { [1 2 3], [4 5 6] }. 
```

В качестве значений могут выступать и нестандартные объекты, созданные на основе классов или структур. Главное требование к ним — наличие компаратора, который позволит множеству сравнивать и упорядочивать элементы.

```cpp
class User {
public:
    User(std::string name, int rd) : name_(name), registration_date_(rd) {}
    
    int GetRegDate() const {
        return registration_date_;
    }
private:
    std::string name_;
    int registration_date_;
};

struct UserComparator {
    bool operator() (const User& u1, const User& u2) const {
        return u1.GetRegDate() < u2.GetRegDate();
    }
};

...

std::set<User, UserComparator> set_of_users{
    User ("Alice"s, 20240907),
    User ("Bobby"s, 20190115),
    User ("Charlie"s, 20220910),
    User ("Mary"s, 20220910),
};
// set_of_users = { 
// ("Bobby", 20190115), 
// ("Charlie", 20220910), 
// ("Alice", 20240907) 
// } 
```

В приведённом примере компаратор `UserComparator` задаёт правило для сравнения объектов типа `User`: они будут упорядочены по дате регистрации (поле `registration_date_`). Поскольку у пользователей Charlie и Mary даты совпадают, они считаются одинаковыми элементами, и множество сохранит только один из них.