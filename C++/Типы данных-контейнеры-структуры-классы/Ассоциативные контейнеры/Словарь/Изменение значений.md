Вы уже знаете, что операция взятия по индексу `[]` позволяет менять значения элементов.

```cpp
std::map<std::string, int> prices = {
    {"Milk"s, 100},
    {"Donut"s, 150},
};

prices["Milk"s] = 99; 
```

Но что будет, если указанного ключа нет в словаре? В случае вектора попытка использовать несуществующий индекс приводит к ошибке. Словарь работает иначе: если элемента с нужным ключом нет, он автоматически добавится со значением по умолчанию.

```cpp
std::map<std::string, int> prices = {
    {"Milk"s, 99},
    {"Donut"s, 150},
};

// Пытаемся изменить значение элемента, которого ещё нет.
prices["Croissant"s] += 10; 

// Вывод:
// Croissant, 10
// Donut, 150
// Milk, 99 
```

При обращении по ключу «Croissant» в словаре появляется новый элемент с таким ключом и значением 0, которое сразу же увеличивается на 10.

В следующей таблице приведены результаты выполнения операции `[]` для различных вариаций вектора и словаря.

||Есть ключ/индекс|Нет ключа/индекса|
|---|---|---|
|`vector`|Ок|Неопределённое поведение|
|`const vector`|Ок|Неопределённое поведение|
|`map`|Ок|Добавляется элемент со значением по умолчанию|
|`const map`|Ошибка компиляции|Ошибка компиляции|

- Вектор работает предсказуемо: возвращает либо найденный элемент, либо ошибку.
- Словарь возвращает элемент в любом случае.
- Константный словарь вообще не допускает обращения к своим элементам с помощью `[]`. В этом случае нужно использовать итераторы.

Это свойство словарей удобно для создания счётчиков, так как позволяет не инициализировать новые элементы вручную.

```cpp
std::string word = "Hello"s;
std::map<char, int> char_counter;

for (auto c : word) {
    char_counter[c]++; 
} 
```

Добавлять элементы таким образом можно в тех случаях, когда поведение программы предсказуемо. В сложном коде для избежания ошибок рекомендуется использовать конструкцию с `find`, которую вы изучили в прошлом уроке.