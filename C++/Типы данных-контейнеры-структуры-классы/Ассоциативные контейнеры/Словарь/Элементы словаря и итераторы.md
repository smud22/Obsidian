Каждый элемент в `std::map` представляет собой пару из ключа и значения: `std::pair<const Key, Value>`. Как и для любой пары, для них работает обращение через `first` и `second`, которое вы уже встречали в некоторых примерах.

```cpp
auto iterator = prices.find("Milk"s); 

// Сохраним элемент целиком в тип pair. 
std::pair<std::string, int> item = *iterator;
std::cout << item.first << ": "s << item.second << std::endl; 
```

Вы могли обратить внимание, что при добавлении элементов в словарь с помощью `insert` ключ и значение заключаются в скобки `{}`. Это нужно, поскольку параметр должен быть типа `pair`.

```cpp
// Можно создать пару с помощью {}.
prices.insert({"Salt"s, 40});

// Или использовать переменную.
std::pair<std::string, int> new_item = {"Sugar"s, 80};
prices.insert(new_item); 
```

Итераторы в `std::map` и в векторе работают аналогично: они определяют позицию элемента (в данном случае — пары), по которой к нему можно обратиться. Итератор `begin` указывает на первый элемент словаря, а `end` — на позицию **за** словарём.

```cpp
std::map<std::string, int> prices = {
    {"Milk"s, 99},
    {"Donut"s, 150},
};

// Выведет значение "Donut".
std::cout << prices.begin()->first << std::endl;

// Ошибка: на позиции end элементов уже нет.
std::cout << prices.end()->first << std::endl; 
```

Подобно вектору, в словаре итераторы позволяют переходить от одного элемента к другому в том порядке, в котором они хранятся.

```cpp
for(auto it = prices.begin(); it!= prices.end(); it++) {
    std::cout << it->first << ": "s << it->second << std::endl;
}

// Вывод:
// Donut: 150
// Milk: 99 
```

У перемещения по словарю есть свои особенности. Как мы говорили в прошлом уроке, `std::map` хранит ключи таким образом, чтобы обеспечивать быстрый доступ к ним, поэтому организация данных сложнее, чем в последовательном векторе. Из-за этого итераторы словаря не поддерживают операции прибавления и вычитания чисел. Зато доступны `--` и `++`:

```cpp
// Переход к следующему элементу с помощью инкремента разрешён.
std::cout << (++accounts.begin())->first << std::endl;

// Переход на указанное количество позиций вызовет ошибку.
std::cout << (accounts.begin() + 3)->first << std::endl; // <- Ошибка! 
```

Для перемещения на определённое количество позиций можно использовать функцию `std::advance`, которая передвигает итератор на заданное количество шагов:

```cpp
std::map<int, std::string> numbers = {
      {1, "one"s},
      {2, "two"s},
      {3, "three"s},
      {4, "four"s},
      {5, "five"s}
};

auto it = numbers.begin(); 
std::advance(it, 3); // Перемещаем итератор на 3 позиции вперёд.

// Выведет: 4, four.
std::cout << it->first << ", "s << it->second << std::endl; 
```

Похожим образом работают функции `std::next` и `std::prev`. Они не меняют итератор, но позволяют получить новый, смещённый:

```cpp
auto other_it = std::prev(it, 2); // other_it -> {2, "two"}.

auto iter_to_last = std::next(other_it, 3); // iter_to_last -> {5, "five"}. 
```

Поскольку итераторы словаря — не итераторы произвольного доступа, функции `advance`, `prev`, `next` не так эффективны, как перемещения итераторов вектора. Под капотом они многократно вызывают `++` либо `--`, в зависимости от направления движения.

Вычитание итераторов друг из друга также недоступно. Чтобы определить количество шагов между двумя итераторами, можно использовать функцию `std::distance`.

```cpp
auto iter_begin = numbers.begin();
auto iter_end = numbers.find("4"s);

// Расстояние между первым элементом и элементом "4" равно 3.
int dist = std::distance(iter_begin, iter_end); 
```