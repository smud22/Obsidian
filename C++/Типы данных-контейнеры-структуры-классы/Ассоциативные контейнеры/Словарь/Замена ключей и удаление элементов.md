Как вы уже знаете, словари не позволяют менять ключи, так как они являются константными: `std::pair<const Key, Value>`.

```cpp
auto it = prices.find("Milk"s);
    
it->second = 220;               // Ок.
it->first = "Сhocolate milk"s;  // Ошибка: попытка изменить константный элемент пары. 
```

Причина снова кроется в сложной структуре «дерева». Все элементы в такой структуре данных упорядочены по ключу, и при изменении одного из них этот порядок будет нарушен. Поэтому, чтобы заменить ключ, необходимо сначала удалить элемент из словаря, а затем вставить новый.

Для удаления элемента используется метод `erase`. Он возвращает логическое значение `true`, если указанный ключ найден и элемент удалён, и `false` в противном случае.

```cpp
auto is_erased = prices.erase("Milk"s);

// Если ключ найден, вставляем новый элемент на место старого.
if (is_erased) { 
    prices.insert({"Сhocolate milk"s, 220});
} else {
    std::cout << "Ключ не найден"s;
}
    
// Donut: 150
// Сhocolate milk: 220 
```

Метод `erase` также позволяет удалять элементы по итератору.

```cpp
auto it = prices.find("Milk"s);

if (it != prices.end()) {
    prices.erase(it);
} 
```

В некоторых случаях бывает необходимо удалить несколько ключей, идущих подряд. `erase` позволяет сделать это с помощью двух итераторов, указывающих на границы диапазона. При этом элемент, соответствующий верхней границе, не входит в диапазон и не удаляется.

Ниже приведён пример с удалением из словаря элементов от `{"Donut"s, 150}` до `{"Milk chocolate"s, 150}` включительно.

```cpp
std::map<std::string, int> prices = {
    {"Donut"s, 150},
    {"Milk"s, 100},
    {"Milk chocolate"s, 150},
    {"Sugar"s, 80},
}; 

// Находим границы диапазона.
auto it_begin = prices.find("Donut"s);
auto it_end = ++prices.find("Milk chocolate"s);

if ((it_begin != prices.end()) && (it_end != prices.end())) {
    prices.erase(it_begin, it_end);
}

// Результат после удаления:
// Sugar, 80 
```

Обратите внимание: чтобы элемент `{"Milk chocolate"s, 150}` попал в удаляемый диапазон, его итератор нужно сдвинуть на следующую позицию, увеличив на 1.

Рассмотрим теперь инвалидацию итераторов. Как вы знаете, итераторы вектора довольно чувствительны: при изменении количества элементов они могут инвалидироваться.

Итераторы `std::map` гораздо более устойчивые. Причина в том, что элементы словаря хранятся не подряд, а разрозненно. Благодаря этому им никогда не нужно переезжать, делая реaллокацию.

Итератор на элемент `std::map` остаётся корректным, если вы:

- Добавляете новый элемент.
- Удаляете другой элемент.
- Меняете значение любого элемента, в том числе того, на который указывает итератор.

Единственный случай, когда итератор действительно будет инвалидироваться, — удаление элемента, на который он указывает.