Получить значение словаря можно с помощью операции взятия по индексу `[]`. Она же позволяет редактировать значения.

```cpp
std::cout << accounts["Mary"s] << std::endl; // Выведет 5555515.
    
accounts["Mary"s] = 700055555;
std::cout << accounts["Mary"s] << std::endl; // Выведет 700055555. 
```

Как видите, ключи работают почти так же, как индексы в векторе. Если бы в нашей задаче ключи были представлены целыми числами, сходство было бы ещё больше.

Для проверки, есть ли элементы в словаре, существует метод `empty`, возвращающий логическое значение. Если нужно узнать точный размер словаря, можно использовать метод `size`.

```cpp
std::map<std::string, uint64_t> accounts {
    {"Jeff"s, 1000000},
    {"Mary"s, 5555515},
};
    
if (accounts.empty()) {
    std::cout << "Словарь пустой. "s;
} else {
    std::cout << "Словарь не пустой. "s;
}
std::cout << "Количество значений = "s << accounts.size() << std::endl; 

// Вывод: "Словарь не пустой. Количество значений = 2" 
```

Несмотря на то что элементы в `std::map` не пронумерованы, их можно перебрать с помощью цикла `for`. Самый простой способ — использовать декомпозицию `auto& [key, value]`.

```cpp
std::map<std::string, uint64_t> accounts {
    {"Jeff"s, 1000000},
    {"Mary"s, 5555515},
    {"Bill"s, 9999999}
};
    
for (auto& [key, value]: accounts) {
    std::cout << key << ", "s << value << std::endl;
}   

// Вывод:
// Bill, 9999999
// Jeff, 1000000
// Mary, 5555515 
```

Обратите внимание, что цикл перебирает элементы по возрастанию ключей, то есть так же, как они хранятся внутри словаря.

При обходе можно менять значения элементов через переменную `value`.

```cpp
for (auto& [key, value]: accounts) {
    value = 0;
}  

// Вывод:
// Bill, 0
// Jeff, 0
// Mary, 0 
```

Однако, если таким же образом попытаться изменить `key`, произойдёт ошибка. Ключи в словарях менять нельзя.

Для обработки словаря можно передать его в функцию.

```cpp
void ShowAccounts(const std::map<std::string, uint64_t>& accounts) {
    for (const auto& [key, value]: accounts) {
        std::cout << key << ", "s << value << std::endl;
    }
}

... 

std::map<std::string, uint64_t> accounts;
ShowAccounts(accounts); 
```

Заранее записывать словарь в переменную необязательно — при необходимости можно передать его напрямую.

```cpp
ShowAccounts(std::map<std::string, uint64_t>{
    {"Jeff"s, 1000000},
    {"Bill"s, 9999999},
}); 
```