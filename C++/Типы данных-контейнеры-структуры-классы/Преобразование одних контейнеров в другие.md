В библиотеке STL предусмотрена возможность создавать новые контейнеры на основе пары итераторов из уже существующих контейнеров. Например, таким образом можно получить `std::set` из элементов вектора.

```cpp
std::vector vec{1, 1, 2, 2, 3, 4, 5, 6};

// Создадим множество из элементов вектора.  
auto unique_elements = std::set<int>(vec.begin(), vec.end());

for (auto item : unique_elements) {
    std::cout << item << " "s;
} 
//Вывод: 1 2 3 4 5 6 . 
```

Аналогично можно выполнить и обратное преобразование, создав вектор из элементов множества.

```cpp
std::set set{'a', 'b', 'c', 'd'};
auto vec = std::vector<char>(set.begin(), set.end());

for (auto item : vec) {
    std::cout << item << " "s;
} 
//Вывод: a b c d . 
```

При объявлении нового контейнера конструктор получает два параметра — итераторы, указывающие на начало и конец диапазона, которые не обязательно должны совпадать с итераторами `begin` и `end`.

```cpp
// Выберем элементы от 'a' до 'с' (не включительно).
auto vec = std::vector<char>(set.begin(), set.find('c'));

// vec = ['a', 'b']. 
```

Подобные преобразования возможны и для других контейнеров — главное, чтобы их элементы были одного типа. Например, превратить множество в словарь не получится, поскольку элементы словаря должны быть парами. Зато это свойство позволяет создавать новые словари на основе существующих, в том числе с новыми компараторами.

В следующем примере мы создадим словарь `new_accounts` с другим правилом сортировки: вместо того, чтобы упорядочивать числовые значения по возрастанию, он будет сравнивать ключи лексикографически.

```cpp
struct Comparator{
    bool operator()(int a, int b) const {
        return std::to_string(a) < std::to_string(b);
    }
};

...
// Словарь со стандартным компаратором.
std::map<int, std::string> accounts {
    {1000000, "Jeff"s}, 
    {5555, "Mary"s},
    {90000, "Jeff"s},
};

// Создадим на его основе новый словарь с Comparator.    
auto new_accounts = std::map<int, std::string, Comparator>(
                             accounts.begin(), accounts.end());

// В первом варианте элементы сортируются по возрастанию числовых ключей:
// 5555, Mary
// 90000, Jeff
// 1000000, Jeff
    
// Во втором варианте ключи сортируются как строки:
// 1000000, Jeff
// 5555, Mary
// 90000, Jeff 
```