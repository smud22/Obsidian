Итераторы используются при работе с контейнерами, в том числе и с векторами. Самый простой способ получить итератор — вызвать метод `begin()`. Для примера возьмём вектор с именами:

```c
std::vector<std::string> client_names = {"Bill", "Jeff", "Mark"};
// Записываем итератор в переменную iter:
/*какой-то возвращаемый тип*/ iter = client_names.begin(); 
```

Итератор, указывающий на элемент этого контейнера, имеет достаточно сложный тип — `std::vector<std::string>::iterator`, включающий в себя и тип контейнера `std::vector`, и тип данных вектора `std::string`. В этом случае чаще используют `auto`, что делает код компактнее:

```c
// Запишем явно возвращаемый тип:
std::vector<std::string>::iterator some_iter = client_names.begin();

// А так проще:
auto auto_iter = client_names.begin(); 
```

Итератор, возвращаемый `begin()`, указывает на первый элемент вектора. В этом случае — строку «Bill». Что ещё можно сделать, используя итератор в качестве переменной?

**Прочитать элемент по итератору**

Чтобы прочитать, что содержится в элементе, на который указывает итератор, используется унарная операция `*`:

```c
// Записать прочитанный элемент в переменную.
std::string first_client_name = *some_iter; 
// Переменной first_client_name будет присвоено значение "Bill".

// Вывести в cout.
std::cout << *some_iter  << std::endl; 
// Вывод: Bill.

// Передать в функцию.
PayRoyalty(*some_iter); 
```

Ещё эта операция называется **разыменованием**.

**Изменить элемент по итератору**

Ещё операция `*` подойдёт, если нужно изменить значение элемента вектора:

```c
*some_iter = "Elon";

// Изменили первый элемент. Теперь в векторе "Elon", "Jeff", "Mark". 
```

**Прочитать поле или вызвать метод класса по итератору**

Если вектор хранит не простые значения, а объекты класса или структуры, то можно обратиться к методу таким образом:

```c
std::vector<Student> students = ...;
std::vector<Point> points = ...;

auto student_iter = students.begin();
auto points_iter = points.begin();

// Если в классе Student есть метод GetAvgScore():
std::cout << (*student_iter).GetAvgScore() << std::endl;
// Вывести поле "x" из структуры Point:
std::cout << (*points_iter).x << std::endl; 
```

Но такая запись с разыменованием и круглыми скобками неудобна и усложняет чтение кода. Вместо этого обращение к методу класса или полю структуры через точку заменяется на стрелку:

```c
std::cout << student_iter->GetAvgScore() << std::endl;
std::cout << points_iter->x << std::endl; 
```

**Удалить элемент по итератору**

Также итератор позволяет удалить элемент вектора, если его передать в метод `erase()`:

```c
client_names.erase(some_iter);

// Теперь в векторе только "Jeff" и "Mark". 
```