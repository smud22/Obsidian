Вы могли задаться вопросом, зачем нужны итераторы. Ведь их можно заменить числовым индексом. Это верно в случае с вектором, но не подойдёт для других контейнеров, в которых нельзя быстро получить элемент по индексу. С такими контейнерами вы познакомитесь в следующей теме.

Несмотря на то что значение элемента вектора можно получить по числовому индексу, без итераторов не обойтись, когда нужно удалить элемент или вставить новый в центр контейнера. Также итераторы необходимы при использовании стандартных алгоритмов, таких как `std::sort` или `std::find_if`, но об этом чуть позже.

Вернёмся к вектору. Итераторы для этого контейнера бывают нескольких видов. С первым из них вы уже знакомы — это обычные итераторы типа `std::vector<T>::iterator`. Второй вид — константные итераторы, которые имеют тип `std::vector<T>::const_iterator`. Такие итераторы не позволяют менять элементы контейнера:

```c
// Обычный итератор превращается в константный:
std::vector<T>::const_iterator iter = client_names.begin();

// Нельзя менять значение, на которое указывает const_iterator.
*iter = "Elon"; // Ошибка!

// Буква "c" в cbegin и cend позволяет получить константный итератор.
auto iter2 = client_names.cbegin();
auto iter3 = client_names.cend(); 
```

Если у вас есть константный вектор, вы не можете менять его элементы. Значит, и итераторы можно получить только константные:

```c
void ProcessClients(const std::vector<Client>& clients) {
    // iter будет иметь тип vector<Client>::const_iterator.
    auto iter = clients.begin();
    
    // ...
} 
```

Другой вид итераторов — **реверсивные итераторы**. Они позволяют проходить контейнер в обратном порядке. Их возвращают методы `rbegin`, `rend`. При этом `rbegin` указывает на последний элемент контейнера, `rend` — на фиктивный перед первым элементом контейнера. `++` будет двигать итератор в направлении от последнего элемента к первому:

```c
std::vector<std::string> names = {"Bill", "Jeff", "Mark"};

// Тут вместо begin и end — rbegin и rend. В остальном мы
// ничего не изменили.
for (auto iter = names.rbegin(); iter != names.rend(); ++iter) {
    std::cout << *iter << std::endl; 
    // Вывод:
    //   Mark
    //   Jeff
    //   Bill
} 
```

Если рассматривать пару итераторов как диапазон, то `v.begin(), v.end()` — это диапазон из всех элементов вектора `v`, а `v.rbegin(), v.rend()` — тот же диапазон, но в обратном порядке.