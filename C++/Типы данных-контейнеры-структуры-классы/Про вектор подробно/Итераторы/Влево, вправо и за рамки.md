Итераторы были бы не очень полезны, если бы их нельзя было двигать. Основные операции перемещения итераторов — `++` и `--`:

```c
std::vector<std::string> client_names = {"Bill", "Jeff", "Mark"};

auto some_iter = client_names.begin();

std::cout << *some_iter << std::endl; 
// Вывод: Bill.

// Подвинем итератор на шаг вправо.
some_iter++; 
std::cout << *some_iter << std::endl; 
// Вывод: Jeff.

// Также на шаг вправо, но левая операция.
// Разница между my_iter++ и ++my_iter
// такая же, как для чисел.
++some_iter; 
std::cout << *some_iter << std::endl; 
// Вывод: Mark.

// Вернём итератор на шаг назад.
some_iter--; 
std::cout << *some_iter << std::endl; 
// Вывод: Jeff. 
```

Итератор вектора называют **двунаправленным** (bidirectional), потому что он поддерживает перемещения вправо и влево (`++` и `--`). Некоторые контейнеры и диапазоны имеют **однонаправленные** итераторы, допускающие только движение вперёд.  
Итераторы вектора являются **итераторами произвольного доступа**. Они поддерживают эффективное перемещение на любое расстояние.

При перемещении нельзя, чтобы итератор выходил за пределы контейнера. Например, у итератора `begin()` не стоит вызывать `--`. Это приводит к неопределённому поведению. Но есть одно исключение: находясь на последнем элементе контейнера, итератор может пойти на один шаг вправо. При этом получится корректный итератор, хотя его и нельзя разыменовывать:

```c
std::vector<std::string> client_names = {"Bill", "Jeff", "Mark"};

auto iter = client_names.begin();

iter++;
iter++;
std::cout << *iter << std::endl; 
// Вывод: Mark.

iter++; // Итератор вышел на один элемент вправо, но это допустимо.
iter--; // Вернули итератор назад.

std::cout << *iter << std::endl; 
// Вывод:  Mark. 
```

В этом примере мы подвинули `iter` на три шага вправо, и он оказался за пределами контейнера. Считается, что такой итератор указывает на **фиктивный элемент** (так называют элемент, которого в реальности не существует). Такой итератор нельзя разыменовывать, то есть применять к нему операцию `*` или `->`.

Итератор, указывающий на фиктивный элемент, — важный атрибут многих алгоритмов. Чтобы его получить, даже не надо много раз вызывать операцию `++`. Есть специальный метод — `end()`, антагонист `begin()`. В отличие от `begin()`, метод `end()` возвращает итератор, не указывающий на корректный элемент контейнера. Этот итератор нельзя двигать вправо, но можно подвинуть влево.

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s04_containers_and_algorithms/image_cc-cnpe.png)

Наличие фиктивного элемента позволяет вызывать `begin()` даже у пустого контейнера. Действительно, `begin()` выдаёт итератор, указывающий на первый элемент. Но что делать, если элементов нет? Указывать на фиктивный элемент. В этом случае `begin()` равен `end()`.

Использовать `end()` можно, например, в цикле для проверки достижения последнего элемента благодаря операции сравнения итераторов `!=`:

```c
std::vector<std::string> names = {"Bill", "Jeff", "Mark"};

// Начальное значение iter — names.begin().
// Выполняем, пока iter != names.end().
// Шаг ++iter — переход к следующему элементу.
for (auto iter = names.begin(); iter != names.end(); ++iter) {
    std::cout << *iter << std::endl;
} 
```

Помимо шагов на соседние элементы, итераторы поддерживают прыжки на заданное количество шагов. Для этого к итератору применяется прибавление и вычитание чисел:

```c
std::vector<std::string> numbers = {"one", "two", "three", "four", 
                                    "five", "six", "seven"};
auto iter = numbers.begin(); // iter => one.

iter += 3; 
// iter => four. Сдвинули на 3 вправо.
auto iter2 = iter - 2; 
// iter2 => two. Сдвинули на 2 влево и записали в новую переменную.

iter -= -3; 
// iter => seven. Сдвиг на -3 влево = сдвиг на 3 вправо.
iter2 += -1; 
// iter2 => one. Сдвиг на -1 вправо = сдвиг на 1 влево. 
```

Или можно использовать алгоритмы `std:advance`, `std::next` и `std::prev` для перемещения итератора:

```c
// Сместим указатель на два вправо.
// Для вектора это то же, что и iter += 2, но
// алгоритм advance работает с любыми итераторами.
std::advance(iter, 2);

auto iter2 = std::next(iter); // iter2 = iter + 1;
auto iter3 = std::prev(iter); // iter3 = iter - 1; 
```

Помимо перемещения итератора, операция сложения также используется, чтобы получить элемент вектора по номеру. Достаточно прибавить нужный номер к `begin()`. Сложение итератора и числа можно использовать, если вам требуется получить итератор на элемент по его порядковому номеру.

```c
std::vector<std::string> numbers = {"one", "two", "three", "four", 
                                    "five", "six", "seven"};
auto iter1 = numbers.begin() + 0; 
// Итератор на нулевой элемент — one.
auto iter5 = numbers.begin() + 4; 
// Итератор на четвёртый элемент — five.

int number;
std::cin >> number;
if (number >= 0 && number < numbers.size()) {
    auto some_iter = numbers.begin() + number;
} 
```

Также получить элемент вектора по номеру можно с помощью квадратных скобок (например, таким образом: `some_vector[15]`).