Итераторы можно использовать для вставки и удаления элементов в любом месте вектора, а не только в конце. Для этого есть методы `insert` и `erase`.

Вставка перед нужным элементом позволяет вставить элемент в любое место, в том числе в конец вектора. Для этого нужно взять итератор, указывающий на фиктивный элемент.

```c
std::vector<std::string> names = {"Bill", "Jeff", "Mark"};

auto iter = ++names.begin(); // Jeff.

// Вставили Илона перед Джеффом.
names.insert(iter, "Elon"); // Bill, Elon, Jeff, Mark. 
```

Можно использовать возвращаемое значение. Это будет итератор, указывающий на новый элемент вектора:

```c
auto iter2 = names.insert(iter, "Elon");
assert(*iter2 == "Elon");

++iter2; // Jeff.

// Удалим Джеффа из вектора:
auto iter3 = names.erase(iter2); // Bill, Elon, Mark

// erase возвращает итератор на элемент, следующий за удалённым.
assert(*iter3 == "Mark"); 
```

Будьте осторожны: такие операции могут быть очень неэффективными. Если нужно удалить несколько элементов, гораздо лучше использовать `std::remove_if`, чем удалять их по одному.

**Инвалидация**

С итераторами нужно быть осторожными, так как у них есть неприятная особенность — **инвалидация**. Это ситуация, при которой итератор перестаёт быть корректным и любая операция с ним приводит к **UB (undefined behavior)** — неопределённому поведению. Случается такое при любом изменении размера вектора, например при добавлении, удалении элементов, вызове метода `resize()`.

Методы, которые инвалидируют итераторы:

- `insert`,
- `erase`,
- `push_back`,
- `pop_back`,
- `clear`,
- `reserve` (запомните этот метод — его рассмотрим позже),
- `resize`.

Не инвалидируют:

- все константные методы (`size()`, `empty()`);
- методы получения итераторов (`begin()`, `end()`, `cbegin()`, `cend()`, `rbegin()`, `rend()`, `crbegin()`, `crend()`);
- чтение и изменение элементов через итератор, `[]`, метод `at`.

Если произошла операция, инвалидирующая вектор, то все итераторы этого вектора, полученные до этой операции, становятся некорректными. Необходимо заново проинициализировать итератор.

Инвалидация обусловлена способом хранения элементов в векторе. Вектор использует некоторую область памяти. Если добавляется новый элемент, а область памяти недостаточна, то вектор переносит элементы в новую область. При этом итераторы продолжают указывать на старую.

Чаще всего итераторы на вектор нужны в моменте: получить итератор, выполнить алгоритм. Сохранять их в долгоживущие переменные можно, но важно помнить: после любой операции, меняющей размер контейнера, итераторы станут невалидными.

Ограничения распространяются и на циклы. Например, такой цикл, дублирующий элементы, будет работать некорректно:

```c
std::vector<int> some_vec = {10, 20, 30};

for (auto iter = some_vec.cbegin(); iter != some_vec.cend(); ++iter) {
    some_vec.insert(iter, *iter);
    iter++; // Ошибка! Итератор инвалидирован.
} 
```

РЕМАРКА: на самом деле такой код может быть валиден, если перед циклом вызвать метод reserve(6) или больше, так как при заранее выделенной памяти, при вставке элементов не будет происходить переаллокации памяти и все итераторы останутся валидными.

Исправим этот код и после выполнения вставки нового элемента заново запишем новое значение в итератор:

```c
for (auto iter = some_vec.cbegin(); iter != some_vec.cend(); ++iter) {
    iter = some_vec.insert(iter, *iter);
    iter++;
}

// В массиве будут числа 10, 10, 20, 20, 30, 30. 
```

Теперь проблема решена, так как в `iter` записали новое значение.

Похожая проблема будет и в range-based for:

```c
for (auto i: some_vec) {
    if (i > 15) {
        some_vec.push_back(i); // Ошибка!
    }
    // Вектор, по которому проходит алгоритм, изменил размер.
    // Итератор инвалидирован.
}

std::vector<int> other_vec;
for (auto i: some_vec) {
    if (i > 15) {
        other_vec.push_back(i); // Ok.
    }
    // Можно вставлять в другой вектор.
    // Это не влияет на итераторы vec.
} 
```