Обратная задача упорядочивания — это рандомизация расположения элементов. Это может использоваться:

- при создании карточной игры, чтобы перемешать карты в колоде;
- для анализа — к примеру, вы получили опытным путём набор данных, но полученную информацию хотите взять не подряд, а использовать случайную выборку;
- в реализации игры для генерации случайного маршрута.

Чтобы сделать что-то случайным образом, в программировании применяют **генераторы псевдослучайных чисел**. Механизма получать настоящую случайность в обычных компьютерах не существует, поэтому и используются псевдослучайные числа. Такие генераторы обладают предсказуемостью. Если знать все параметры генератора, то можно вычислить, какое случайное число будет следующим. Если продолжать эту процедуру, то можно получить последовательность псевдослучайных чисел.

Вот пример последовательности из 10 чисел от 1 до 1 000 000, полученной генератором псевдослучайных чисел: 137417, 594628, 635917, 656650, 816188, 605287, 364793, 421639, 394494, 737286.

Такие последовательности кажутся хаотичными и непредсказуемыми, для этого даже существуют математические критерии. Но эти числа всё равно сгенерированы однозначным алгоритмом. Один из самых известных таких алгоритмов — **вихрь Мерсенна**. Для использования его в C++ существует тип `std::mt19937` из заголовочного файла `<random>`.

```cpp
// Создадим генератор.
std::mt19937 gen;

// Нам нужны числа от 1 до 1 000 000.
std::uniform_int_distribution<> dist(1, 1'000'000);

// Создаём вектор для хранения случайных чисел из пяти элементов.
std::vector<int> random_numbers(5);

// И заполним его случайными числами.
for (auto& num : random_numbers) {
    num = dist(gen);
} 
```

Чтобы получать из генератора `gen` числа в определённом диапазоне, нам понадобилось создать распределение `dist`. Объект класса `uniform_int_distribution` позволяет получать из генератора целые числа в некотором диапазоне, причём все числа появляются с равной вероятностью.

При запуске этой программы вы получите такую последовательность: 814724, 135478, 905792, 835009, 126987. Как вы можете заметить, последовательность будет всегда одна и та же. Чтобы изменить её, можно поменять **сид** (от англ. `seed` — зерно). Сид задаётся в конструкторе генератора и может кардинально изменить числа, которые вы получите:

```cpp
// Используем сид 1:
std::mt19937 gen(1);

std::uniform_int_distribution<> dist(1, 1'000'000);
std::vector<int> random_numbers(5);
for (auto& num : random_numbers) {
    num = dist(gen);
}

// Теперь в векторе будут числа 417022, 997185, 720325, 932558, 115. 
```

Но так мы всё равно не получим случайность, ведь сид жёстко задан в коде. Однако есть ещё один способ получить случайный сид — **аппаратный генератор** случайного значения. В C++ он задан классом `std::random_device`. Объект этого класса позволяет получать невоспроизводимое число на основе системного времени и других характеристик оборудования. Этот способ получения псевдослучайных чисел намного медленней и его не рекомендуется использовать для логики программы. Но можно использовать для получения сида:

```cpp
// Аппаратный генератор случайного значения:
std::random_device rd;   

// Инициализация начальным значением, полученным от аппаратного генератора:
std::mt19937 gen(rd());  
```

Таким образом, для получения случайных чисел нужно три компонента.

Кроме этого генератор случайных чисел можно использовать для перемешивания элементов вектора. Для этого подойдёт алгоритм `std::shuffle`. Он принимает диапазон вектора и генератор псевдослучайных чисел третьим параметром.

```cpp
// Заполним вектор значениями.
std::vector<int> numbers{1, 2, 3, 4, 5, 6};

// Создание генератора со случайным начальным значением.
std::random_device rd;  
std::mt19937 gen_shuffle(rd());

// Перемешаем элементы в векторе.
std::shuffle(numbers.begin(), numbers.end(), gen_shuffle); 
```

При запуске этой программы вы будете получать разные перестановки чисел в векторе. Например: 3, 1, 6, 2, 5, 4 или 4, 6, 3, 2, 5, 1.