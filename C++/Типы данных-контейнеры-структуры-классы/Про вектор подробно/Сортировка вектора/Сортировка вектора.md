Чтобы разобраться, как работает сортировка данных в контейнере, возьмём в качестве примера результаты гонок на спортивных яхтах. По правилам подсчёта результатов, первое место занимает та команда, которая набрала меньше всего очков.

Используем структуру `Team` и определим операцию сравнения:

```cpp
struct Team {
    auto operator<=>(const Team& other) const {
        return points <=> other.points;
    }
    
    std::string name;
    int points;
}; 
```

Так как в условии задано, что первое место занимает команда с наименьшим числом очков, то подходит стандартный компаратор `std::less`, который используется по умолчанию:

```cpp
std::vector<Team> teams;
teams.push_back({.name = "Team1", .points = 5});
teams.push_back({.name = "Team2", .points = 2});
teams.push_back({.name = "Team3", .points = 26});
teams.push_back({.name = "Team4", .points = 18});

std::sort(teams.begin(), teams.end()); 
```

Мы сформировали таблицу результатов. Но ведущему надо объявлять команды для награждения в обратном порядке. Чтобы помочь ведущему, можно сделать две вещи:

- Пересортировать список, используя компаратор `std::greater`.
- При выводе элементов начать с последнего.

Либо можно применить алгоритм `std::reverse`, который поменяет порядок элементов на противоположный:

```cpp
std::reverse(teams.begin(), teams.end()); 
```

Теперь команды будут расположены в обратном порядке. Так как `std::reverse` работает с итераторами, то это позволяет изменить порядок как всей последовательности, так и её части.

Не стоит применять `std::reverse` сразу после `std::sort` — лучше поменять компаратор и использовать только один алгоритм. Но `reverse` поможет, если порядок уже известен и его нужно поменять на противоположный.