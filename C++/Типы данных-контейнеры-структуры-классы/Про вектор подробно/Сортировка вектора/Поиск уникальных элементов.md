Предположим, перед вами стоит задача удалить из вектора все дубликаты, оставив каждый встречающийся элемент по одному разу. Например, дан такой вектор: 4, 2, 6, 3, 1, 5, 3, 2, 15, 0, 3, 1. Можно решить задачу следующим образом:

```cpp
std::vector<int> GetUnique(const std::vector<int>& src) {
    std::vector<int> result;
    for (auto i : src) {
        // Добавляем элемент, если его ещё нет в result.
        if (std::find(result.begin(), result.end(), i) == result.end()) {
            result.push_back(i);
        }
    }
    return result;
} 
```

Такой алгоритм работает, но медленно. Почему — вы узнаете далее из раздела об алгоритмической сложности.

Если отсортировать вектор, получим такую последовательность:

0, 1, 1, 2, 2, 3, 3, 3, 4, 5, 6, 15.

Одинаковые элементы встали рядом. Теперь убрать дубликаты проще:

```cpp
std::vector<int> GetUniqueOfSorted(const std::vector<int>& src) {
    if (src.empty()) {
        return {};
    }
    
    std::vector<int> result;
    result.push_back(src.front());
    for (auto iter = src.begin() + 1; iter != src.end(), ++iter) {
        // Если элемент не равен предыдущему добавим его.
        if (*iter != *(iter - 1)) {
            result.push_back(*iter);
        }
    }
    return result;
} 
```

В таком подходе есть проблема — удаление элементов приводит к инвалидации итераторов. Именно поэтому алгоритм `std::unique`, решающий эту задачу, ничего не удаляет. Вместо этого он переставляет задублированные элементы в конец вектора. Затем удалить их можно одной командой:

```cpp
auto to_del = std::unique(some_vec.begin(), some_vec.end());
some_vec.erase(to_del, some_vec.end()); 
```

Как видите, мы воспользовались итератором, который вернул алгоритм. Он указывает на элементы, которые нужно удалить, — они переставлены в конец.

Алгоритм `std::unique` уберёт в конец только идущие подряд дубликаты. Поэтому если цель — удалить их все, то его нужно применять к отсортированному контейнеру.

Похожим образом действуют алгоритмы `std::remove` и `std::remove_if`. Они не удаляют элементы, а переставляют их в конец. Но при этом возвращают итератор на то место, с которого нужно удалять.

```cpp
std::vector<int> vec = {4, 2, 6, 3, 1, 5, 3, 2, 15, 0, 3, 1};

// Удалим двойки.
auto to_del = std::remove(vec.begin(), vec.end(), 2);
vec.erase(to_del, vec.end());
// vec == {4, 6, 3, 1, 5, 3, 15, 0, 3, 1};

// Удалим нечётные числа.
auto to_del2 = std::remove_if(vec.begin(), vec.end(), [](int i){
    return i % 2 != 0;
});
vec.erase(to_del2, vec.end());
// vec == {4, 6, 0}; 
```