Попробуем применить функциональный стиль к заполнению сигнала. Для этого нам пригодятся алгоритмы `generate` и `transform`. Первый имеет брата-близнеца — `generate_n`. Он использует функциональный объект, чтобы заполнить требуемый диапазон. Функциональный объект вызывается многократно и результаты этих вызовов используются для заполнения контейнера:

```cpp
std::vector<int16_t> signal;
signal.reserve(48000);

const double amplitude = 15000;
const int wave_length = 200;

// Используем mutable-лямбда функцию. Она может менять захваченные значения.
// В данном случае меняем i, который инициализируем в 
// квадратных скобках: i = 0.
auto generator = [=, i = 0]() mutable {
    // Возвратим значение. Алгоритм generate_n добавит его
    // в вектор.
    return amplitude * sin(2 * i++ * std::numbers::pi / wave_length);
};

std::generate_n(std::back_inserter(signal), wave_length, generator); 
```

Плюс такого подхода в том, что вы можете сохранить генератор нужного сигнала и использовать его, когда требуется. Более того, можно применять к нему различные модификации.

`transform` тоже записывает значения, но работает по-другому. Он читает элементы из одного диапазона, применяет к ним указанную функцию и записывает результат функции в другой диапазон. `transform` похож на `copy`, но добавляет применение функции.

Теперь используем `transform`, чтобы применить затухание:

```cpp
void ApplyDecay(std::vector<int16_t>& signal, size_t max_length) {
    size_t decay_length = std::min(signal.size(), max_length);
    
    auto transformer = [=, i = decay_length](int16_t source) mutable {
        double factor = double(i--) / decay_length;
        return static_cast<int16_t>(source * factor);
    };

    auto start_pos = signal.end() - decay_length;
    std::transform(start_pos, signal.end(), start_pos, transformer);
} 
```

`transform` принимает:

- входной диапазон (два итератора),
- выходной итератор,
- преобразователь (функциональный объект).

Преобразователь применяется к каждому элементу входного диапазона. Результат записывается по выходному итератору. В этом случае мы использовали одинаковые входной и выходной диапазон, чтобы менять значения вектора без выделения вспомогательной памяти (по-английски часто используется слово inplace).