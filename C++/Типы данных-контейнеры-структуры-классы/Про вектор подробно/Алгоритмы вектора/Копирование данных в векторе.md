Ранее мы создали вектор с одиночным меандром, используя `std::fill_n`. Чтобы заполнить меандром весь вектор, необходимо скопировать одиночный меандр. Для этого применим алгоритм `std::copy_n`. Как и у `std::fill_n`, у него есть числовой параметр — количество значений. Но в отличие от `std::fill_n`, он работает с двумя диапазонами элементов. Эти диапазоны могут принадлежать как одному контейнеру, так и к двум разным.

`std::copy_n` копирует элементы из одного диапазона в другой. Он принимает три параметра:

1. Итератор, указывающий откуда копировать.
2. Количество элементов.
3. Итератор, указывающий куда копировать.

Так это будет выглядеть в коде:

```cpp
const int wave_length = 200;
for (size_t offset = wave_length;
    offset < signal.size(); 
    offset += wave_length) {
    
    // Копируем первые wave_length элементов в позицию offset.
    std::copy_n(meander.begin(), wave_length, signal.begin() + offset);
} 
```

Такой цикл содержит ошибку, приводящую к проблеме, которую не всегда легко обнаружить. Последнее копирование может выйти за пределы вектора. При частоте дискретизации 48 000 этого не произойдёт, так как `wave_length` укладывается в размере вектора целое число раз. Но если уменьшить вектор, например, до 44 100 элементов, то программа войдёт в состояние неопределённости.

В условии цикла проверили: `offset < signal.size()`, а затем заполнили 200 элементов, начиная с `offset`. Условие гарантирует, что в векторе есть один свободный элемент, но не гарантирует, что их 200. Никаких дополнительных проверок `copy_n` не осуществляет.

Решить проблему можно двумя способами:

1. Будем проверять, что в векторе ещё есть 200 элементов:
    
    ```cpp
     for (size_t offset = wave_length;
          // Меняем условие цикла. Обратите внимание на <=.
          offset + wave_length <= signal.size(); 
          offset += wave_length) {
         
         std::copy_n(meander.begin(), wave_length, signal.begin() + offset);
     }
      
    ```
    
2. Будем копировать осторожно, проверяя, уместится ли следующая порция с информацией в оставшуюся часть контейнера:
    
    ```cpp
     for (size_t offset = wave_length;
          offset < signal.size();
          // Не делаем инкремент здесь.
         ) {
         
         // Определим, сколько максимально можем скопировать.
         int max_copy = signal.size() - offset;
         
         // Сколько нужно скопировать: wave_length элементов,
         // но не больше max_copy.
         auto to_copy = std::min(wave_length, max_copy);
         
         // Теперь копируем не wave_length, а to_copy.
         std::copy_n(meander.begin(), to_copy, signal.begin() + offset);
    
         // Сделаем инкремент здесь.
         offset += to_copy;
     }
      
    ```
    

Первый способ имеет недостаток: в векторе могут остаться незаполненные значения. Второй способ заполнит всё целиком.

Так это будет выглядеть в коде:

```cpp
const int wave_length = 200;
for (size_t offset = wave_length;
    offset < signal.size(); 
    offset += wave_length) {
    
    // Копируем первые wave_length элементов в позицию offset.
    std::copy_n(meander.begin(), wave_length, signal.begin() + offset);
} 
```

Такой цикл содержит ошибку, приводящую к проблеме, которую не всегда легко обнаружить. Последнее копирование может выйти за пределы вектора. При частоте дискретизации 48 000 этого не произойдёт, так как `wave_length` укладывается в размере вектора целое число раз. Но если уменьшить вектор, например, до 44 100 элементов, то программа войдёт в состояние неопределённости.

В условии цикла проверили: `offset < signal.size()`, а затем заполнили 200 элементов, начиная с `offset`. Условие гарантирует, что в векторе есть один свободный элемент, но не гарантирует, что их 200. Никаких дополнительных проверок `copy_n` не осуществляет.

Решить проблему можно двумя способами:

1. Будем проверять, что в векторе ещё есть 200 элементов:
    
    ```cpp
     for (size_t offset = wave_length;
          // Меняем условие цикла. Обратите внимание на <=.
          offset + wave_length <= signal.size(); 
          offset += wave_length) {
         
         std::copy_n(meander.begin(), wave_length, signal.begin() + offset);
     }
      
    ```
    
2. Будем копировать осторожно, проверяя, уместится ли следующая порция с информацией в оставшуюся часть контейнера:
    
    ```cpp
     for (size_t offset = wave_length;
          offset < signal.size();
          // Не делаем инкремент здесь.
         ) {
         
         // Определим, сколько максимально можем скопировать.
         int max_copy = signal.size() - offset;
         
         // Сколько нужно скопировать: wave_length элементов,
         // но не больше max_copy.
         auto to_copy = std::min(wave_length, max_copy);
         
         // Теперь копируем не wave_length, а to_copy.
         std::copy_n(meander.begin(), to_copy, signal.begin() + offset);
    
         // Сделаем инкремент здесь.
         offset += to_copy;
     }
      
    ```
    

Первый способ имеет недостаток: в векторе могут остаться незаполненные значения. Второй способ заполнит всё целиком.