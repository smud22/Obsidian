Предположим, вы решили написать программу, которая считает, сколько строк кода пишет каждый из программистов в отделе за неделю. Эту задачу можно реализовать с помощью цикла `for`:

```cpp
// Количество строк, написанных первым программистом
// с понедельника по пятницу.
std::vector<int> first_programer = {100, 210, 134, 89, 256};
int sum_first_programer = 0;

for (int lines : first_programer) {
    sum_first_programer += lines;
}

// Количество строк, написанных вторым программистом
// с понедельника по пятницу.
std::vector<int> second_programer = {670, 110, 578, 321, 83};
int sum_second_programer = 0;

for (int lines : second_programer) {
    sum_second_programer += lines;
} 
```

Получается много циклов. Но если использовать алгоритм `std::accumulate`, то код станет компактнее. Чтобы его использовать, кроме библиотеки `algorithm`, надо подключить библиотеку `numeric`. Алгоритм `std::accumulate` принимает на вход указатели на начало и конец контейнера, а третьим параметром — начальное значение, получится так:

```cpp
std::vector<int> first_programer = {100, 210, 134, 89, 256};
int sum_first_programer = std::accumulate(
    first_programer.begin(), // Начало диапазона.
    first_programer.end(),   // Конец диапазона.
    0                        // Начальное значение.
);

std::vector<int> second_programer = {670, 110, 578, 321, 83};
int sum_second_programer = std::accumulate(
    second_programer.begin(),
    second_programer.end(), 
    0
); 
```

Выведем результат на печать:

```cpp
std::cout << sum_first_programer << std::endl;
std::cout << sum_second_programer << std::endl; 
```

Получим — 789 строк у первого программиста, а у второго — 1762.

Кроме чисел, `std::accumulate` умеет складывать и символы. Возьмём вектор символов:

```cpp
std::vector<char> source_line = 
    {'A', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 's'}; 
```

Применим `std::accumulate` и создадим новую строку:

```cpp
std::string new_line = std::accumulate(
    source_line.begin(), 
    source_line.end(), 
    std::string{}        // Начинаем с пустой строки.
);
std::cout << new_line.c_str() << std::endl;
// Будет выведено: Algorithms. 
```

Также этот алгоритм умеет работать и с вектором строк:

```cpp
std::vector<std::string> v_str{"Hello", ", ", "Algorithms", "!"};
std::string ss = std::accumulate(v_str.begin(), v_str.end(), std::string{});
std::cout << ss.c_str() << std::endl;
// Будет выведено: Hello, Algorithms! 
```

Вы можете использовать `std::accumulate` для сложения тех типов, у которых определена операция сложения. Если необходимо сложить объекты, к примеру, объекты структур, у которых нет встроенной операции сложения, достаточно определить её.

```cpp
// Определим структуру с двумя числами - int и double.
struct TwoNums {
    int int_num;
    double double_num;
};

// Создадим вектор экземпляров структуры TwoNums.
std::vector<TwoNums> v_structs{{1, 1.2}, {2, 1.2}, {3, 1.2}, {4, 1.2}};

// Попоробуем использовать std::accumulate для сложения элементов вектора.
TwoNums  nums = std::accumulate(v_structs.begin(), v_structs.end(), TwoNums {}); 
```

Программа не соберётся, и компилятор выдаст такую ошибку:

```cpp
error: no match for 'operator+' (operand types are 'TwoNums' and 'TwoNums')
  __init = __init + *__first;
           ~~~~~~~^~~~~~~~~~ 
```

Она говорит о том, что нет операции сложения для двух элементов с типом `TwoNums`. Определим операцию сложения:

```cpp
TwoNums operator+(const TwoNums& lhs, const TwoNums& rhs) {
    return {lhs.int_num + rhs.int_num, lhs.double_num + rhs.double_num};
} 
```

При наличии определённой операции сложения `std::accumulate` сможет сложить элементы из контейнера с любыми типами.