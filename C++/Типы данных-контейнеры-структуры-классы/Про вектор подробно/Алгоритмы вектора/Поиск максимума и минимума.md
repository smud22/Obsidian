Для реализации поиска максимальных и минимальных значений в стандартной библиотеке есть несколько алгоритмов, которые решают эту задачу. Их можно разделить на две группы:

1. `std::min`, `std::max`, `std::minmax`. Принимают элементы и возвращают искомое значение:
    
    ```cpp
    int max_int = std::max(4, 5);  // 5.
    int min_int = std::min(-7, 3); // -7.
    auto [min, max] = std::minmax(14, 6);  // min = 6, max = 14.
    auto [min2, max2] = std::minmax(
        {-0.4, 1e+5, 2.});  // min2 = -0.4, max2 = 1e+5. 
    ```
    
2. `std::min_element`, `std::max_element`, `std::minmax_element`. Принимают диапазон как пару итераторов и возвращают итератор на искомый элемент:
    
    ```cpp
    // Позиции:              0  1  2  3  4  5  6  7
    std::vector<int> nums = {1, 2, 5, 6, 7, 3, 7, 1};
    auto it = std::max_element(nums.begin(), nums.end());
    std::cout << "Максимум на позиции " << (it - nums.begin()) 
              << ", значение: " << (*it) << std::endl;
    // Напечатает:
    // Максимум на позиции 4, значение: 7. 
    ```
    
    Алгоритм `max_element` возвратил итератор на максимальный элемент вектора. Аналогично работают `min_element`, `minmax_element`.
    

Все функции поиска минимума и максимума работают с типами, для которых определена операция «меньше». Для использования в этих алгоритмах других типов достаточно определить `operator<` для нужного типа. Вот так может выглядеть перегрузка этой операции для структуры `TwoNums`:

```cpp
bool operator<(const TwoNums& lhs, const TwoNums& rhs) {
    auto to_tuple = [](const TwoNums& val){
        return std::tie(val.int_num, val.double_num);
    };
    
    // Сравним структуры как кортежи.
    return to_tuple(lhs) < to_tuple(rhs);
} 
```

Найдём минимум и максимум:

```cpp
// Создадим вектор экземпляров структуры TwoNums.
std::vector<TwoNums> vec{{1, 1.2}, {20, 1.8}, {20, 1.2}, {0, 1.2}};

auto [min, max] = std::minmax_element(vec.begin(), vec.end());
// *min = {0, 1.2};
// *max = {20, 1.8}; 
```

### И снова лямбда

Алгоритмы `min`, `max`, `minmax` и их аналоги для контейнера используют стандартный компаратор `std::less`. Но в них можно использовать любой другой компаратор. Например, найдём максимум по **модулю**, используя функцию `std::abs`:

```cpp
std::vector<int> vec_int = {-5, 3, -9, -1, 6};

// Максимум по абсолютному значению:
auto it = std::max_element(vec_int.begin(), vec_int.end(), [](int a, int b) {
    return std::abs(a) < std::abs(b); 
});

// Выведет текст - "Максимальный элемент по модулю: -9".
std::cout << "Максимальный элемент по модулю: " << *it << std::endl; 
```
