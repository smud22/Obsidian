Чтобы решить, что делать с переменной типа `optional` дальше, нужно знать, пустая она или нет. Один из способов сделать это мы уже показали в примере выше.

```cpp
if (found_p) { // Проверяем, есть ли значение. 
```

`optional` имеет перегруженное приведение к логическому типу: если переменная не пустая, проверка `if (optional)` вернёт `true`.

Аналогичный результат можно получить с помощью метода `has_value`.

```cpp
if (found_p.has_value()) {
    std::cout << found_p->x << ", "s << found_p->y;
} else {
    std::cout << "Значение не найдено"s;
} 
```

Чтобы извлечь значение из `optional`, можно воспользоваться записью через звёздочку `*` или же методом `value`. Разница между ними в том, что в первом случае программа не выдаст ошибку, но это приведёт к неопределённому поведению: некорректному значению, падению программы или иному эффекту.

```cpp
auto found_p = FindByX(std::vector{p_1, p_2}, 101); // Точка не найдена.
auto point = *found_p; // Ошибки нет.
  
// Но в переменную point попадают некорректные значения.
// Например, -716429744 и 32767.
std::cout << point.x << ", " << point.y;  
```

Если же попытаться получить значение из пустого `optional` с помощью `value`, это приведёт к ошибке.

```cpp
auto found_p = FindByX(std::vector{p_1, p_2}, 101); // Точка не найдена.
auto point = found_p.value(); // Ошибка: std::bad_optional_access. 
```

О том, как можно обработать такую ошибку, вы узнаете из темы об исключениях.

Чтобы избежать подобных проблем, стоит всегда проверять значение перед его извлечением или же использовать метод `value_or`. Он работает аналогично `value`, но в случае пустого `optional` возвращает значение по умолчанию.

```cpp
auto found_p = FindByX(std::vector{p_1, p_2}, 101); // Точка не найдена.

// Значения нет — метод вернёт точку (0, 0).
auto point = found_p.value_or(Point<int>{0, 0}); 
std::cout << point.x << ", " << point.y; // 0, 0. 
```

Почему же C++ допускает существование механизма, работа с которым требует ручной проверки, без которой можно всё сломать? Это позволяет языку избегать накладных расходов (оверхеда) на автоматические проверки. Благодаря этому `optional` можно использовать даже в самом высокопроизводительном коде, где каждый `if` на счету.