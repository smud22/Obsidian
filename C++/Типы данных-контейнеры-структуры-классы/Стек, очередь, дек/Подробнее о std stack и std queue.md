Стек поддерживает три операции — добавление, удаление вершины и её просмотр. Вместо `std::stack` подошёл бы `std::vector`.

`std::stack` можно заменить на `std::vector` — там тоже есть методы для добавления и удаления элементов с конца (`push_back` и `pop_back`). Получается, `stack` — это урезанная версия `vector`? На самом деле `std::stack` может быть вектором «под капотом».

В стандартной библиотеке C++ не существует контейнеров `std::stack` и `std::queue`. Это адаптеры, которые используют подходящие контейнеры, а нам предоставляют интерфейс, соответствующий стеку или очереди.

`std::vector` — подходящий контейнер для `std::stack`, так как он эффективно реализует нужные для стека методы: вставку и удаление элементов с конца. Другие подходящие и стандартные контейнеры — `std::list` и `std::deque`.

```cpp
// Создание стека с разными контейнерами «под капотом».
std::stack<int, std::vector<int>> stack1; // Это вектор с интерфейсом стека.
stack1.push(1); // «Под капотом» вызывается метод вектора push_back.

std::stack<int, std::deque<int>> stack2; // deque используется по умолчанию.
std::stack<int, std::list<int>> stack3; 
```

Для `std::queue` подходящими контейнерами являются `std::list` и `std::deque`. Обратите внимание: `std::vector` не подходит для очереди, так как удаление первого элемента вектора не эффективно.

```cpp
// Создание очереди с разными контейнерами «под капотом».
std::queue<int, std::deque<int>> queue1; // deque используется по умолчанию.
std::queue<int, std::list<int>> queue2; 
```

`std::list` тоже можно использовать как двустороннюю очередь — в двусвязном списке можно эффективно манипулировать элементами в начале или в конце. Но на практике `std::deque` используется как очередь (или двусторонняя очередь) чаще, чем `std::list`, по причине лучшей производительности. Поэтому же `std::deque` используется по умолчанию для адаптеров `std::queue` и `std::stack`.