Кроме LIFO, используется принцип **FIFO**. Элементы, добавленные первыми, первыми же и будут удалены. Этот принцип можно проиллюстрировать на примере очереди покупателей в магазине.

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s04_containers_and_algorithms/image_cc-kdcb.jpg)

Неслучайно контейнер, реализующий принцип FIFO, называется `queue` (англ. «очередь»).

В очереди доступны операции вставки элементов в конец (`push`) и их удаления из начала (`pop`).

```cpp
// Создание пустой очереди с элементами типа int.
std::queue<int> queue;
// Можно добавлять элементы в конец очереди.
queue.push(100);
queue.push(200);
// Или посмотреть в начале. Это не удаляет элемент из очереди.
std::cout << queue.front() << std::endl; // 100.
// И удалить первый элемент.
queue.pop();
// Теперь остался только один элемент.
std::cout << queue.size() << " "s << queue.front() << std::endl; // 1 200 
```

ажное применение такого контейнера — очередь задач. Это может быть что угодно: копирование файла, загрузка фотографии, вычисление, открытие программы. Допустим, что у задачи есть метод `bool Finished()`, чтобы проверять, закончена она или нет. И есть метод `void DoSomeWork()`, чтобы сделать очередную часть работы. Можно сделать класс — планировщик задач и добавлять в него задачи, а он будет последовательно выполнять их, справедливо распределяя между ними время.

```cpp
template <class Task>
class Scheduler {
public:
    void PushTask(const Task& task) {
        // При добавлении новой задачи добавляем её в конец очереди.
        queue_.push(task);
    }
    
    bool DoWork() {
        if (queue_.empty()) {
            // Если задач нет, сообщаем, что вся работа выполнена.
            return false;
        }
        
        // Берём первую задачу в очереди и делаем её часть.
        auto task = queue_.front();
        queue.pop();
        task.DoSomeWork();
        
        // Если задача не выполнена, добавляем её в конец очереди.
        if (!task.Finished()) {
            queue_.push(task);
        }
        
        return true;
    }
  
private:
    std::queue<Task> queue_;
}; 
```

Такой алгоритм планирования называется **round-robin**. Все задачи выполняются по очереди. Например, этот алгоритм можно было бы использовать в операционной системе для распределения вычислительных ресурсов между процессами.

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s04_containers_and_algorithms/image_cc-jthl.png)