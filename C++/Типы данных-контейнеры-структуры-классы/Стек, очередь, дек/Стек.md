**Стек** — это ещё один шаблонный контейнер. В C++ он представлен классом `std::stack`. В этом контейнере изменять можно только последний элемент:

- `push` — добавление элемента;
- `pop` — удаление последнего элемента;
- `top` — чтение или изменение последнего элемента.

Последний элемент называется **вершиной стека**. Можно представить стек как башню из кубиков, в которой можно что-то делать только с верхним.

```cpp
// Создание пустого стека с элементами типа int.
std::stack<int> my_stack;
// Можно добавлять элементы на вершину стека.
my_stack.push(100);
my_stack.push(200);

// Или посмотреть, какой элемент сейчас сверху. Это не удаляет его из стека.
std::cout << my_stack.top() << std::endl; // 200.

// И удалить последний элемент.
my_stack.pop();

// Теперь остался только один элемент — 100.
std::cout << my_stack.size() << " "s << my_stack.top() << std::endl; // 1 100

// Так можно поменять вершину.
my_stack.top() = 42; 
```

Этот принцип хранения называется **LIFO**. Элементы, добавленные на вершину стека, оказываются первыми на очереди к удалению. Такой подход работы с данными часто встречается и в алгоритмах, и в жизни.

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s04_containers_and_algorithms/image_cc-xjkx.png)

Не всегда очевидно, что для решения той или иной задачи подходит стек. Вот представьте, что на проводе сидят птицы разных цветов. Если две одинаковые по цвету птицы оказываются соседними, то они улетают. Процесс повторяется, пока есть пара одинаковых рядом. В итоге останутся только птицы без соседей такого же цвета. Сколько их останется?

![](https://code.s3.yandex.net/CPP/assets/c01_2024/s04_containers_and_algorithms/image_cc-kcmv.png)

Стек подходит для этой задачи, так как в любой момент важен только цвет последней, неудалённой птицы. Обрабатывать данные можно последовательно, а одинаковые цвета сразу удалять из стека.

```cpp
// В этом стеке будут храниться цвета неудалённых птиц.
std::stack<int> birds;

int color;
while (std::cin >> color) {
    // Для текущей птицы цвета color.
    // Если её цвет совпадает с предыдущим цветом, 
    // нужно удалить предыдущий цвет и не добавлять текущий.
    if (!birds.empty() && birds.top() == color) {
        birds.pop();
    } else {
        // Если предыдущий не совпадает (или его нет), нужно добавить текущий.
        birds.push(color);
    }
}
// В стеке хранятся неудалённые птицы (цвета). Их количество и есть ответ.
std::cout << birds.size() << std::endl; 
```

Такой алгоритм будет эффективно решать задачу: он пробегает по входным данным один раз и сразу удаляет всех птиц, которые должны быть удалены.