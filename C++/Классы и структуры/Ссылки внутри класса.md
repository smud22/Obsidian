Полями классов и структур могут быть не только значения вроде `int`, `double`, `std::string` и `std::vector`, но и ссылки. В этом случае поле хранит не само значение, а ссылку на какую-то внешнюю переменную, не связанную с классом. Ссылки применяются в следующих случаях:

- один объект должен пользоваться уже существующим объектом,
- несколько объектов должны совместно использовать один и тот же объект.

Рассмотрим пример со структурой `Cat` — «кошка». Если эта кошка не гуляет сама по себе, то есть человек, которому она принадлежит:

```cpp
struct Cat {
    std::string name;
};

struct CatOwner {
    void CallCat() {
        std::cout << cat.name << ", come here!" << std::endl;
    }
    
    // Используем &, чтобы хранить не копию кошки, 
    // а ссылку на существующую кошку.
    Cat& cat;
}; 
```

Теперь, если переименовать кошку, человек будет звать её по новому имени:

```cpp
int main() {
    Cat pussy_cat{"Simba"};
    // При инициализации человека передаём экземпляр кошки.
    CatOwner ivan{pussy_cat};
    ivan.CallCat(); // Simba, come here!
    
    // Иван зовёт кошку по новому имени,
    // потому что хранит тот же объект, который
    // содержится в переменной pussy_cat.    
    pussy_cat.name = "Bagheera";
    ivan.CallCat(); // Bagheera, come here!
} 
```

Рассмотрим ещё один пример — музыкальную группу, у которой на всех один и тот же плейлист (список песен). Каждый из музыкантов играет по очереди очередную песню из списка, а после последней — начинает сначала. Если изменить плейлист, то все использующие его музыканты обновят репертуар.

Класс `Musician`, моделирующий музыканта, будет содержать поле ссылочного типа:

```cpp
#include <cassert>
#include <iostream>
#include <string>
#include <vector>

class Musician {
public:
    ...
    // Играет следующую мелодию из плейлиста.
    void PlayNextSong() {
        assert(!play_list_.empty());
        song_index_ %= play_list_.size();
        std::cout << name_ << " играет мелодию '" << GetCurrentSong() << "'" << std::endl;
        ++song_index_;
    }

    std::string GetCurrentSong() const {
        assert(song_index_ < play_list_.size());
        return play_list_[song_index_];
    }
    
private:
    std::string name_;
    // Амперсанд показывает, что поле ссылочного типа.
    const std::vector<std::string>& play_list_;
    size_t song_index_ = 0;
}; 
```

Музыкант хранит константную ссылку на плейлист, так как не вносит изменения в список песен.

Поля-ссылки тоже должны быть проинициализированы до выполнения тела конструктора. Для их инициализации используется список инициализации конструктора:

```cpp
class Musician {
public:
    Musician(const std::string& name, const std::vector<std::string>& play_list)
        : name_{ name }
        // Инициализируем ссылку на список песен.
        , play_list_{ play_list } {
    }
    ...
}; 
```

Теперь можно создать две музыкальные группы, каждую со своим репертуаром песен:

```cpp
int main() {
    std::vector<std::string> songs1{"Yesterday", "Yellow Submarine", "Hey Jude", "Help!"};
    std::vector<std::string> songs2{"В лесу родилась ёлочка", "Танец маленьких лебедей"};

    // Вася и Петя играют в одной группе. У них на двоих один список песен.
    Musician musician1{"Вася", songs1};
    Musician musician2{"Петя", songs1};
    // У Саши свой репертуар.
    Musician musician3{"Саша", songs2};

    for (int i = 0; i < 2; ++i) {
        musician1.PlayNextSong();
        musician2.PlayNextSong();
        musician3.PlayNextSong();
    }
    ...
} 
```

Программа выведет текст:

```cpp
Вася играет мелодию 'Yesterday'
Петя играет мелодию 'Yesterday'
Саша играет мелодию 'В лесу родилась ёлочка'
Вася играет мелодию 'Yellow Submarine'
Петя играет мелодию 'Yellow Submarine'
Саша играет мелодию 'Танец маленьких лебедей' 
```

Если теперь изменить вектор `songs2` и добавить к Саше напарника Колю, то у их дуэта будет новый репертуар:

```cpp
int main() {
    ...
    // Изменим репертуар Саши.
    songs2 = {"Коробейники", "Светит месяц", "К Элизе", "Соната № 6"};
    // К Саше присоединился Коля. Он начнёт играть песни с начала списка.
    Musician musician4{"Коля", songs2};
    
    for (int i = 0; i < 2; ++i) {
        musician3.PlayNextSong();
        musician4.PlayNextSong();
    }
} 
```

Коля начнёт играть мелодии с начала списка, а Саша продолжит с третьей позиции:

```cpp
Саша играет мелодию 'К Элизе'
Коля играет мелодию 'Коробейники'
Саша играет мелодию 'Соната № 6'
Коля играет мелодию 'Светит месяц' 
```



Рассмотрим использование полей-ссылок в классе `TVControl`, над которым вы трудились в одной из задач. Раньше требовалось передавать ссылку на телевизор в каждый метод этого класса:

```cpp
class TVControl {
public:
    static bool ReadAndApplyCommand(TV& tv) {
        std::string action;
        if (!(std::cin >> action)) {
            std::cout << "Invalid command"s << std::endl;
            return false;
        }
        if (action == "TurnOn"s) {
            TurnOn(tv);
            return true;
        }
        /* Аналогично обрабатываются остальные команды. */
        return false;
    }
    
private:
    static void Info(TV& tv);
    static void TurnOn(TV& tv);
    static void TurnOff(TV& tv);
    static void SelectChannel(TV& tv);
};
 
```

Чтобы сделать пульт более «осязаемым» и иметь возможность создавать его экземпляры, необходимо сохранить ссылку на телевизор, то есть добавить поле `tv_` типа `TV&` внутрь класса `TVControl`. Так мы свяжем пульт с телевизором. Для этого в конструктор `TVControl` нужно передать ссылку на телевизор, а в списке инициализации класса проинициализировать поле `tv_`:

```cpp
class TV {
public:
    void TurnOn() {...}
    ...
};

// Пульт телевизора.
class TVControl {
public:
    // В конструктор передаётся ссылка на телевизор, которым управляет пульт.
    TVControl(TV& tv)
        : tv_{tv}  // Поле-ссылка может быть проинициализировано только в списке инициализации.
    {
    }

private:
    TV& tv_; // Ссылка на телевизор, которым управляет пульт.

private:
    // Методы класса TVControl.
}; 
```

![Справа нарисован телевизор, слева от него схематично изображён пульт, который подписан классом TVControl и ссылкой TV& tv_ внутри.](https://code.s3.yandex.net/CPP/assets/c01_2024/s02_qt_basics/references-in-class_1.png)

Теперь, чтобы обратиться к телевизору внутри методов класса `TVControl`, достаточно использовать поле-ссылку `tv_`. Благодаря ему пульт «знает», с каким телевизором он взаимодействует.

```cpp
class TVControl {
public:
    ...
    // Этот метод больше не статический.
    bool ReadAndApplyCommand() const {
        std::string action;
        if (!(std::cin >> action)) {
            std::cout << "Invalid command"s << std::endl;
            return false;
        }
        if (action == "TurnOn"s) {
            // Больше не нужно передавать в этот метод телевизор.
            TurnOn();
            return true;
        }
        /* Аналогично обрабатываются остальные команды. */
        return false;
    }
private:
    void TurnOn() const {
        // Чтобы обратиться к телевизору, просто обращаемся к нему по полю-ссылке.
        tv_.TurnOn();
        std::cout << "Turning on"s << std::endl;
    }
    ...
}; 
```

Обратите внимание, что методы `TVControl` объявлены константными и при этом вызывают неконстантные методы класса `TV`. Так можно делать, потому что телевизор — это внешний объект по отношению к пульту. Пульт хранит ссылку на телевизор, а не содержит внутри себя телевизор. Константность методов не распространяется на объекты, на которые ссылаются поля класса.

Чтобы использовать связку «пульт — телевизор», сначала нужно создать телевизор. Затем создать пульт, передав в конструктор ссылку на телевизор. Команды, отдаваемые пульту, будут приводить к изменению состояния телевизора:

```cpp
int main() {
    TV lounge_tv;
    TVControl tv_control{lounge_tv};
    // Теперь пульт связан с телевизором lounge_tv.

    // Телевизор изначально выключен.
    assert(!lounge_tv.IsTurnedOn());

    // Даём пульту команду включения телевизора.
    tv_control.ReadAndApplyCommand();
    // Распознав команду, пульт вызовет связанный с ней метод телевизора.
} 
```

Отметим, что внутри каждого экземпляра `TVControl` хранится своя ссылка на телевизор. Например, можно создать несколько пультов, каждый из которых ссылается на свой телевизор. Или сделать несколько пультов, которые управляют одним телевизором.

При этом нельзя изменить телевизор, к которому привязан пульт. Ссылка задаётся один раз в списке инициализации конструктора и остаётся неизменной до конца жизни объекта. Попытка изменить ссылку ни к чему не приведёт:

```cpp
class TVControl {
public:
    // Этот метод будет работать не так, как вы думаете.
    void ChangeTV(TV& other_tv) {
        // Вместо того чтобы изменить ссылку, мы
        // скопируем другой телевизор на место tv_.
        tv_ = other_tv;
    }
    ...
private:
    ...
    TV& tv_; 
};

int main() {
    TV lounge_tv{"ТВ в гостиной"};
    TV living_room_tv{"ТВ в спальне"};
    
    // Проверяем имя телевизора в гостиной.
    assert(lounge_tv.GetName() == "ТВ в гостиной"s);
    TVControl control{lounge_tv};
    control.ChangeTV(living_room_tv);
    
    // Вместо того чтобы изменить ссылку на телевизор, этот метод 
    // перезаписал сам телевизор.
    assert(lounge_tv.GetName() == "ТВ в спальне"s);
} 
```

В следующей программе пульты `control_1` и `control_2` ссылаются на телевизор `tv1`, поэтому им можно управлять, используя оба пульта. А пульт `control_3` ссылается на `tv2`. Телевизором `tv2` можно управлять только через пульт `control_3`.

```cpp
int main() {
    TV tv1, tv2;

    // Пульты control_1 и control_2 привязаны к телевизору tv1.
    // Пульт control_3 привязан к tv2.
    TVControl control_1{tv1};
    TVControl control_2{tv1};
    TVControl control_3{tv2};

    // Управлять телевизором tv1 можно равнозначно
    // с помощью пультов control_1 и control_2.
    control_1.ReadAndApplyCommand();
    control_2.ReadAndApplyCommand();

    // Телевизором tv2 управляет только пульт control_3.
    control_3.ReadAndApplyCommand();
    control_3.ReadAndApplyCommand();
    assert(tv2.GetCurrentChannel() == 70);
} 
```

![[Pasted image 20251219184929.png]]
![[Pasted image 20251219184954.png]]
![[Pasted image 20251219185009.png]]