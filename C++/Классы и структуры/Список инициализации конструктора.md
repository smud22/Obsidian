

```cpp
class Carol {
public:
    Carol() { std::cout << "Carol is created"s << std::endl; }
private:
    // Теперь Алиса и Боб — поля класса Carol.
    Alice alice_;
    Bob bob_;
};

int main() {
    std::cout << "Enter main"s << std::endl;
    Carol carol;
    std::cout << "Exit main"s << std::endl;
} 
```

Запустим программу и увидим, что конструкторы полей класса вызываются до выполнения тела конструктора этого класса:

```cpp
Enter main
Alice is created
Bob is created
Carol is created
Exit main 
```

В C++ классы и структуры конструируются по следующим правилам:

- Сначала конструируются поля класса в порядке их расположения внутри класса.
- Затем выполняется тело конструктора класса.

Таким образом, когда выполняется конструктор, все поля класса уже сконструированы. Это логично, так как код в теле конструктора может начать использовать поля класса, а для этого они должны находиться в проинициализированном состоянии.
![[Pasted image 20251219181326.png]]
![[Pasted image 20251219181341.png]]
В процессе конструирования объекта класса `Computer` должны быть сконструированы поля `motherboard_` и `display_`. При конструировании поля `motherboard_` сперва конструируются поля `memory_` и `cpu_`, а после них вызовется тело конструктора `Motherboard`. После конструирования полей класса `Сomputer` вызовется тело его конструктора.

### **Список инициализации конструктора**

Этот механизм позволяет указать параметры инициализации для выбранных полей класса:

```cpp
class Carol {
public:
    Carol(int alice_age)
        : alice_{alice_age} // Вызывается конструктор Alice::Alice(int age).
        , name_("Luis"s)   // Инициализируем поле строкового типа. Можно использовать круглые скобки, однако фигурные скобки являются более универсальными.
    {
        std::cout << "Carol is created"s << std::endl; 
    }

    std::string GetName() const {
        return name_;
    }
private:
    Alice alice_;
    Bob bob_;
    std::string name_;
};

int main() {
    Carol carol{17};
    std::cout << "Name: " << carol.GetName() << std::endl;
} 
```

В списке инициализации ставится `:`, затем через запятую перечисляются поля с инициализаторами. Этот список указывается перед телом конструктора.

В этом примере мы явно указали, что поле `alice_` инициализируется не конструктором по умолчанию, а конструктором, принимающим целое число. В классе `Bob` есть конструктор по умолчанию, поэтому в списке инициализации мы его пропустили, чтобы писать меньше кода. Для конструирования поля `name_` мы вызвали конструктор, принимающий строку.

Запустив программу, видим:

```cpp
Alice(17) is created
Bob is created
Carol is created
Name: Luis 
```

### **Порядок инициализации**

Порядок, в котором будут вызваны конструкторы полей, зависит только от порядка объявления полей в классе. Их порядок в списке инициализации не имеет значения:

```cpp
class David {...};

class Carol {
public:
    Carol(int alice_age, const std::string& david_surname)
        // Поля класса проинициализируются в порядке: 
        // alice_, bob_, david_, так как
        // они в таком порядке перечислены в самом классе.
        : david_(david_surname)
        , alice_{alice_age}
    {
        std::cout << "Carol is created"s << std::endl; 
    }

private:
    Alice alice_; // Это поле будет инициализировано первым.
    Bob bob_;     // Это вторым.
    David david_; // Это третьим.
};

int main() {
    Carol carol(17, "Beckham"s);
} 
```

Однако некоторые компиляторы могут предупреждать о том, что поля в списке инициализации перечислены не в том порядке, в каком они указаны в самом классе. Поэтому порядок лучше соблюдать и в списке инициализации, чтобы не вводить в заблуждение тех, кто будет читать код.

Даже если тип поля класса имеет конструктор по умолчанию, для инициализации поля следует использовать не тело конструктора, а список инициализации. Так будет сгенерирован более компактный и эффективный код — вместо инициализации поля и последующего присваивания нового значения выполняется только инициализация.

```cpp
// Так делать плохо.
class Person {
public:
    Person(const std::string& name, const std::string& surname)
        /* Сначала у полей name_ и surname_ вызывается конструктор по умолчанию. */
    {
        /* Затем проинициализированным полям присваивается новое значение. */
        name_ = name;
        surname_ = surname;
    }
private:
    std::string name_;
    std::string surname_;
};

// Так делать хорошо.
class Person {
public:
    Person(const std::string& name, const std::string& surname)
        // Инициализируем поля name_ и surname_.
        : name_{name}
        , surname_{surname} {
    }
private:
    std::string name_;
    std::string surname_;
}; 
```

Список инициализации — это также единственный способ инициализации полей, которые являются константами. Поля-константы нельзя изменять в методах класса и в теле конструктора. Константные поля в классах и структурах используются редко, поскольку так объекту класса нельзя будет присвоить новое значение. Кроме того, они препятствуют некоторым оптимизациям компилятора.

```cpp
class Person {
public:
    Person(const std::string& name)
        : name_{name} {
        // В теле конструктора изменить значение поля name_ уже нельзя.
    }
private:
    const std::string name_;
};

int main() {
    Person p1{"John"s};
    Person p2{"Peter"s};

    // Следующая строка не скомпилируется, так как внутри класса Person есть константное поле.
    p1 = p2;
} 
```