**Конструктор** — это особая функция-член класса, которая для каждого объекта вызывается один раз — в момент создания экземпляра класса или структуры. Конструктор предназначен для инициализации экземпляра этого класса. Конструктор описывается подобно методам класса, но есть несколько особенностей:

- Имя конструктора в C++ должно совпадать с именем класса.
- У конструктора не указывается тип возвращаемого значения, даже `void`.

Конструктор может использоваться, чтобы задать начальные значения полей:

```cpp
class Rational {
public:
    // Это конструктор, который инициализирует дробь нужными 
    // значениями числителя и знаменателя.
    Rational(int numerator, int denominator) {
        assert(denominator != 0);
        numerator_ = numerator;
        denominator_ = denominator;
    }
    ...
private:
    int numerator_;
    int denominator_;
};

int main() {
    // Конструктор можно вызвать, создав объект.
    // Параметры можно передать в фигурных скобках.
    Rational half{1, 2};

    // После работы конструктора Rational поля
    // получили переданные в параметрах значения. 
    assert(half.GetNumerator() == 1 &&
           half.GetDenominator() == 2);

    // Вызвать конструктор явно нельзя.
    // Единственный способ — создать новый объект.
    half.Rational(10, 15); // <-- Ошибка!
} 
```

В классе можно объявить ноль, один или несколько конструкторов. В случае нескольких конструкторов они должны различаться количеством или типом параметров. В случае нуля конструкторов компилятор «под капотом» создаст конструктор по умолчанию. Так происходило у всех классов, которые вы встречали в курсе до этого. Как и методы класса, конструктор можно объявить внутри описания класса, а определить за его пределами, например, в `.cpp` файле.

```cpp
class Person {
public:
    // Это конструктор, определённый внутри описания класса.
    Person(const std::string& name) {
        /* В теле конструктора задаются начальные значения полей. */
        name_ = name;
    }

    // Этот конструктор объявлен внутри класса, но будет определён вне класса.
    // Вместо тела конструктора ставим точку с запятой.
    Person(const std::string& name, const std::string& surname);
private:
    std::string name_;
    std::string surname_;
};

// Определение конструктора вне класса (например, в .cpp-файле).
Person::Person(const std::string& name, const std::string& surname) {
    name_ = name;
    surname_ = surname;
} 
```


```cpp
// Вызываем конструктор с двумя параметрами, 
// чтобы проинициализировать 2/3. Можно использовать
// как круглые, так и фигурные скобки.
Rational two_third(2, 3);
Rational two_third_2{2, 3};

// С константностью теперь тоже всё в порядке.
const Rational three_fifth{3, 5};

// Вызовем другой конструктор. Он принимает один параметр.
// Эта дробь хранит значение 5/1.
Rational five(5);
Rational five_2{5};

// Объект можно создать без переменной.
assert(Rational(1, 10).GetDenominator() == 10);
assert(Rational{1, 10}.GetDenominator() == 10);

// Это можно применять в сочетании с auto.
auto one_tenth = Rational(1, 10);

// Конструктора, который принимает строку в классе 
// Rational, нет, поэтому следующая строчка не скомпилируется.
Rational error("hello"s);  // <-- Ошибка! 
```

Компилятор сообщает, что не может найти в классе `Rational` **конструктор по умолчанию** (англ. default constructor). Так называется конструктор без параметров. Конструктор по умолчанию — особый конструктор, который компилятор может сгенерировать автоматически. В классе `Rational` он создавал дробь 0/10/1. Однако как только мы явно объявили в классе хотя бы один **параметризованный конструктор** (так называют конструктор с параметрами), компилятор не будет генерировать конструктор по умолчанию. Ведь если классу понадобился конструктор с параметрами, значит, требуется инициализация посложнее, чем задать полям значение по умолчанию. Поэтому компилятор перестраховывается.

Можно написать конструктор по умолчанию явно:

```cpp
class Rational {
public:
    Rational() {
        /* Числитель и знаменатель уже равны 0 и 1. Ничего не делаем. */
    }
    /* Остальные конструкторы и методы класса. */
private:
    // Значения полей по умолчанию формируют дробь 0/1.
    int numerator_ = 0;
    int denominator_ = 1;
}; 
```

В нашем случае в объявлении полей класса уже заданы подходящие значения, поэтому лучше всего вместо тела конструктора по умолчанию написать `= default`. Так мы явно скажем компилятору: «Можешь смело сгенерировать конструктор по умолчанию», — и наличие параметризованных конструкторов не будет ему помехой.

```cpp
class Rational {
public:
    Rational() = default;
    /* Остальные конструкторы и методы класса. */
private:
    // Значения полей по умолчанию формируют дробь 0/1.
    int numerator_ = 0;
    int denominator_ = 1;
}; 
```

Ситуации, когда структуре нужен конструктор:

- Для структуры нет подходящего значения по умолчанию — одно или несколько полей требуют явного указания значения. Например, в структуре, хранящей информацию о пользователе, логин и пароль должны быть непустыми.
- Имеет смысл ограничить количество способов проинициализировать структуру. Например, для структуры `Point` нужно задать либо обе координаты явно, либо ни одной.
- При инициализации полей нужно как-то проверить или скорректировать внешние параметры. Например, не позволить задать отрицательный радиус окружности. Хотя это уже повод заменить структуру на класс.

Но чаще писать в структуре конструктор не нужно. Например, если:

- Нужно сохранить возможность использовать назначенную инициализацию.
- У всех полей структуры есть подходящие значения по умолчанию, при этом явная инициализация одного поля не требует явной инициализации других полей.

![[Pasted image 20251219180757.png]]