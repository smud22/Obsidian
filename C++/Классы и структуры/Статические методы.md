Методы классов и структур неявно принимают указатель на объект класса, чтобы метод знал, у какого объекта он вызван. Но всегда ли это необходимо?

Предположим, что при разработке класса `TV` в нём был выделен метод `IsValidChannel`, который проверяет, что номер канала находится в диапазоне от 1 до 99 включительно.

```cpp
class TV {
public:
    bool SelectChannel(int channel) {
        if (!is_turned_on_ || !IsValidChannel(channel)) {
            // Нельзя выбрать канал с номером вне диапазона от 1 до 99, а также когда телевизор выключен.
            return false;
        }
        channel_ = channel;
        return true;
    }

    bool IsValidChannel(int channel) {
        return channel >= 1 && channel <= 99;
    }
private:
    bool is_turned_on_;
    int channel_ = 1;
}; 
```

Этот метод неявно получает указатель `this`, но не обращается ни к полям, ни к методам класса. С одной стороны, он напоминает свободную функцию. С другой — `IsValidChannel` имеет прямое отношение к телевизору и нигде, кроме этого класса, не используется. Поэтому нет нужды выносить его в отдельную функцию.

Так как все телевизоры имеют один и тот же диапазон допустимых каналов, делаем вывод, что метод `IsValidChannel` относится не к какому-то отдельно взятому телевизору, а к телевизорам в общем.

```cpp
int main() {
    TV tv1, tv2;
    // Не имеет значения, у какого телевизора вызван метод IsValidChannel.
    std::cout << tv1.IsValidChannel(42) << ' ' 
              << tv2.IsValidChannel(100) << std::endl;
} 
```

В C++ для такой цели используются **статические методы**. Чтобы сделать метод статическим, в начале записывается ключевое слово `static`.

Внутри методов этого же класса статический метод вызывают, как и обычный, по имени. А чтобы вызвать его в остальных местах программы, не обязательно создавать экземпляр класса, можно вызвать его по полному имени: `ИмяКласса::ИмяМетода`.

```cpp
class TV {
public:
    bool SelectChannel(int channel) {
        // Статический метод этого же класса вызывается по имени.
        if (!is_turned_on_ || !IsValidChannel(channel)) {
            return false;
        }
        channel_ = channel;
        return true;
    }

    // Теперь IsValidChannel стал статическим.
    static bool IsValidChannel(int channel) {
        return channel >= 1 && channel <= 99;
    }
    ...
};

int main() {
    // Статический метод вызывается без создания объекта.
    // Для этого указывают имя класса.
    std::cout << TV::IsValidChannel(42) 
              << ' ' << TV::IsValidChannel(100);

    TV tv1;
    // Можно вызвать статический метод и с указанием объекта, 
    // но так обычно не делают.
    tv1.IsValidChannel(25);
} 
```

У статических методов есть особенности, которые отличают их от обычных методов.

- С ними не связан никакой экземпляр класса, поэтому статические методы не получают указатель `this`.
- Так как текущего объекта нет, то из статического метода нельзя обратиться к данным объекта.
- Также из статического метода нельзя вызывать методы объекта — за исключением статических.
- Если снаружи в статический метод передали экземпляр класса, то статический метод может обращаться к его полям и методам, в том числе приватным.

```cpp
class TestClass {
public:
    static void StaticMethod() {
        // Ошибка: нельзя вызвать нестатический метод из статического.
        NonStaticMethod();

        // Когда есть экземпляр класса, можно вызывать его нестатические методы
        // и обращаться к полям.
        TestClass test_object;
        test_object.NonStaticMethod();
        test_object.data_ = 42;

        // Из статических методов можно вызывать другие статические методы, даже приватные.
        AnotherStaticMethod();
    }
    void NonStaticMethod() { }
private:
    static AnotherStaticMethod() { }
    int data_ = 0;
}; 
```