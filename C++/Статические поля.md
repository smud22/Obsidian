Статическое поле — общее для всех экземпляров класса. Оно создаётся при запуске программы и уничтожается при её завершении. Для доступа к статическим полям не нужен объект, поэтому их можно использовать и из статических методов. Чтобы объявить статическое поле, надо перед его типом написать ключевое слово `static`.

```cpp
#include <vector>

struct GearSpeedRange {
    Gear gear;
    int min_speed;
    int max_speed;
};

class Car {
    ...
    static bool IsSpeedValidForGear(int speed, Gear gear);
private:
    bool engine_is_on_ = false;
    int speed_ = 0;
    Gear gear_ = Gear::NEUTRAL;

    // Объявляем таблицу диапазонов скоростей статической и константной,
    // чтобы она была одна всю программу и не изменялась.
    static const std::vector<GearSpeedRange> speed_ranges_;
}; 
```

После объявления статического поля его нужно определить за пределами класса. Обычно для этого используют .cpp-файл, в котором размещаются методы класса. Как и при объявлении методов класса за его пределами, нужно указывать полное имя статического поля в виде `ИмяКласса::имя_поля_`.

```cpp
// Это файл car.cpp. Он содержит реализацию класса Car.

#include "car.h"

// Так определяется статическая переменная за пределами класса.
// Наполняем вектор значениями.
const std::vector<GearSpeedRange> Car::speed_ranges_ = {
    { Gear::NEUTRAL, 0, 150 },
    { Gear::FIRST, 0, 30 },
    { Gear::SECOND, 20, 50 },
    { Gear::THIRD, 30, 70 },
    { Gear::FOURTH, 40, 100 },
    { Gear::FIFTH, 60, 150 },
    { Gear::REVERSE, 0, 30 },
};

bool Car::IsSpeedValidForGear(int speed, Gear gear) {
    for (auto& range : speed_ranges_) {
        if (range.gear == gear) {
            return range.min_speed <= speed && speed <= range.max_speed;
        }
    }
    return false;
} 
```

Теперь метод `Car::IsSpeedValidForGear` стало легче читать, а таблицу скоростей движения — редактировать.

Начиная с C++17, статические переменные класса можно определить в .h-файле, прямо внутри класса или структуры. Для этого поле помечают ключевым словом `inline`.

```cpp
class Car {
    ...
private:
    // Так статическое поле объявляется и определяется внутри класса.
    inline static const std::vector<GearSpeedRange> speed_ranges_ = {
        { Gear::NEUTRAL, 0, 150 },
        { Gear::FIRST, 0, 30 },
        { Gear::SECOND, 20, 50 },
        { Gear::THIRD, 30, 70 },
        { Gear::FOURTH, 40, 100 },
        { Gear::FIFTH, 60, 150 },
        { Gear::REVERSE, 0, 30 },
    };
}; 
```

Статические поля есть и у стандартных классов. Например, в классе `std::string` есть статическое поле [`npos`](https://en.cppreference.com/w/cpp/string/basic_string/npos). В зависимости от контекста использования оно либо означает конец строки, либо сигнализирует об ошибке:

```cpp
std::string text = "A quick brown fox jumps over the lazy dog";
std::string needle; // Иголка, которую мы будем искать в стоге сена.
std::cin >> needle; // Вводим текст для поиска.

// Метод find возвращает позицию в строке, с которой начинается искомый текст.
// Если текст не найден, возвращается значение std::string::npos.
if (const size_t found_at = text.find(needle); found_at != std::string::npos) {
    std::cout << needle << " is found at position " << found_at << std::endl;
} else {
    std::cout << needle << " was not found" << std::endl;
} 
```

Так как статические поля класса используются всеми экземплярами класса совместно, чаще всего их делают константными. Иначе их изменение может неожиданно повлиять на работу всех экземпляров класса.

![[Pasted image 20251218205350.png]]