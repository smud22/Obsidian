Кроме глобальных объектов потоков `std::cin`, `std::cout`, `std::cerr`, приложение может создавать потоки, позволяющие считывать данные из строк и выводить в строки. Для этого служат классы строковых потоков, объявленные в заголовочном файле `<sstream>`:

- [`std::istringstream`](https://en.cppreference.com/w/cpp/io/basic_istringstream) — поток чтения из строки.
- [`std::ostringstream`](https://en.cppreference.com/w/cpp/io/basic_ostringstream) — поток для вывода в строку.
- [`std::stringstream`](https://en.cppreference.com/w/cpp/io/basic_stringstream) — поток, который может использоваться для чтения и записи в строку.

Каждый из этих потоков хранит внутри себя строку. При выводе в них данные записываются в строку, а при вводе считываются из строки. При этом в консоль ничего не выводится. Получить строку можно, вызвав метод `str`:

```cpp
#include <cassert>
#include <sstream> // Подключаем строковые потоки.
#include <string>

int main() {
    using namespace std::literals;
    
    std::string name = "Harry"s,
                surname = "Potter"s;

    // Создаём поток в переменной out и выводим в него данные.
    std::ostringstream out;
    out << name << ' ' << surname;

    // Данные, выведенные в поток, можно получить методом str.
    std::string out_data = out.str();
    assert(out_data == "Harry Potter"s);
} 
```

Если же объявлена переменная типа `std::istringstream`, будет создан поток ввода, из которого можно читать данные. Эти данные не упадут с неба — их нужно передать потоку в конструктор.

```cpp
#include <cassert>
#include <sstream>
#include <string>

int main() {
    using namespace std::literals;

    // Создаём поток, из которого можно прочитать строку "Harry Potter".
    std::istringstream in{"Harry Potter"s};
    
    // Читаем имя и фамилию из созданного потока.
    std::string name, surname;
    in >> name >> surname;

    assert(name == "Harry"s);
    assert(surname == "Potter"s);
} 
```

Мы передали данные в конструктор потока, а затем по очереди прочитали их, используя операцию `>>`. Поместить данные в `istringstream` можно не только через конструктор — есть вариант обновить данные в уже существующем объекте, вызвав метод `str`:

```cpp
in.str("new string in the stream");
// Теперь поток содержит строку "new string in the stream". 
```

Потоки `istringstream` и `ostringstream` можно использовать для разных целей. Например, чтобы преобразовать строку в число и наоборот:

```cpp
#include <cassert>
#include <sstream>
#include <string>

int main() {
    using namespace std::literals;
    int n;

    // Конвертируем строку в число.
    std::istringstream in{"12321"s};
    in >> n;
    assert(n == 12321);

    // Конвертируем число в строку.    
    std::ostringstream out;
    out << 112233;
    assert(out.str() == "112233"s);
} 
```

Однако в таких простых случаях не принято использовать потоки. Лучше применять функции `std::to_string`, `std::stoi` или более современные аналоги: `std::from_chars`, `std::format`. Использование строковых потоков имеет смысл, если вам нужно преобразовывать большой объём данных — либо для унификации: чтобы в некоторых случаях работать со стандартным потоком `stdin` или `stdout`, а в некоторых — со строкой.

Кроме потоков `std::istringstream` и `std::ostringstream` существует также `std::stringstream`, который выполняет сразу обе функции: и потока ввода, и потока вывода.