Чтобы такого избежать, переменную при объявлении инициализируют. Для этого при объявлении переменной структурного типа:

1. После имени переменной напишите символ `=`.
2. Затем внутри фигурных скобок перечислите значения полей в том же порядке, в каком поля объявлены внутри структуры.
    
    ```cpp
    int main() {
     // Так инициализируется переменная примитивного типа:
     double mass = 10.5;
    
     // А так инициализируется структура:
     Person person = {"John Doe"s, 30, Gender::MALE };
     ...
    } 
    ```
    

Откомпилируем и запустим программу. Увидим, что теперь поля проинициализированы:

```cpp
Name: John Doe
Age: 30
Gender: Male 
```

Если перечислить только часть полей, то остальные примитивные поля будут проинициализированы нулевым значением и его аналогами:

- Для чисел с плавающей запятой `float` и `double` таким значением будет `0.0`.
- Для `bool` — `false`.
- Для перечислимого типа — значение, численно равное нулю. По умолчанию это первое значение из перечислимого типа.
    
    ```cpp
    int main() {
      Person person = {"John Doe"s};
      ...
    } 
    ```
    

Теперь возраст будет равен нулю, а пол примет значение `Gender::MALE`, так как в перечислении `Gender` значение `MALE` стоит на первом месте.

```cpp
Name: John Doe
Age: 0
Gender: Male 
```

Переменные структурного типа можно присваивать друг другу. При этом значениям всех полей одной структуры присваиваются значения соответствующих полей другой структуры.

```cpp
int main() {
    Person person = {"John Doe"s, 30, Gender::MALE};
    Person person2 = {"Ivan Petrov"s, 25, Gender::MALE};

    person2 = person;
    // Теперь поля person2 имеют те же значения, что и поля person.
    std::cout << person.name << std::endl; // Напечатает строку "John Doe".
    std::cout << person2.name << std::endl; // Тоже напечатает "John Doe".
} 
```

Фигурные скобки можно использовать не только для инициализации, но и при присваивании:

```cpp
Person person;

person = {"John Doe"s, 30, Gender::MALE};

// Ещё один способ:
person = Person{"John Doe"s, 30, Gender::MALE}; 
```

В примере мы использовали конструкцию `Person{"John Doe"s, 30, Gender::MALE}`. Подобная конструкция позволяет создать объект внутри выражения без объявления переменной.

C++ — язык с долгой историей. По мере развития в нём появились и другие способы инициализации переменных-структур, которые вы можете встретить при чтении кода:

```cpp
int main() {
    // Знак = можно не писать.
    Person p1{ "Sarah Connor", 35, Gender::FEMALE };

    // Автоматическое определение типа.
    auto age = 42;      // age имеет тип int и значение 42.
    auto weight = 74.5; // weight имеет тип double и значение 74.5.

    // Автоматическое определение типа работает и со структурами.
    auto p2 = Person{ "Lara Croft"s, 21, Gender::FEMALE };
} 
```

Когда структура содержит несколько подряд идущих полей одинакового типа, то, не видя структуру, можно запутаться, какой из параметров за что отвечает.

```cpp
#include <iostream>

struct Robot {
    double energy;
    double speed;
};

// Представьте, что main находится далеко от описания структуры Robot.
int main() {
    using namespace std::literals;
    
    // В этом месте трудно понять, какое из чисел 30.0 и 25.7 задаёт 
    // энергию, а какое — скорость.
    Robot robot = { 30.0, 25.7 };
    std::cout << "Energy: "s << robot.energy << ", Speed: "s 
              << robot.speed << std::endl;
} 
```

Если в будущем решим изменить порядок полей структуры `Robot`, то легко можем забыть обновить порядок в местах, где инициализируются переменные этого типа. В результате программа будет компилироваться, но работать будет неправильно.

Чтобы защититься от этого, применяется так называемая **назначенная инициализация** (англ. designated initialization). При ней мы явно указываем имена полей вместе с их значениями. Поля должны быть перечислены в порядке их объявления внутри структуры:

```cpp
int main() {
    Robot robot1 { .energy = 30.0, .speed = 25.7 };

    // Пропускать поля можно.
    // Поле energy получит нулевое значение.
    Robot robot2 { .speed = 10.4 };
} 
```

Если перечислить поля в порядке, отличном от указанного в структуре, будет ошибка:

```cpp
int main() {
    // Ошибка: порядок полей не совпадает с тем, как они объявлены в структуре.
    Robot robot { .speed = 25.7, .energy = 3.23 }; 
} 
```

Назначенная инициализация требует, чтобы компилятор поддерживал стандарт C++20. В заданиях, связанных с использованием фреймворка Qt, компилятор может поддерживать только предыдущий стандарт — C++17, поэтому в них у вас не получится использовать эту возможность языка. В остальных заданиях смело используйте назначенную инициализацию, когда она улучшает читаемость кода.